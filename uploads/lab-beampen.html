<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Pattern Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Add QuillJS dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.0-rc.2/dist/quill.snow.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.0-rc.2/dist/quill.min.js"></script>
    <!-- Add FileSaver.js for RTF file creation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        :root {
            --primary: #5D5CDE;
            --primary-dark: #4949B3;
            --primary-light: #8281E6;
            --light-bg: #FFFFFF;
            --dark-bg: #181818;
            --light-text: #333333;
            --dark-text: #E0E0E0;
            --light-border: #DDDDDD;
            --dark-border: #444444;
            --density-highlight: #9C27B0; /* Purple highlight for density tab */
            --letter-highlight: #22c55e; /* Green highlight for letter examples */
            --warning-text: #e53e3e; /* Red text for warnings */
            
            /* Added variable for rhythm bar width */
            --rhythm-bar-width: 11px;
            
            /* Updated rhythm colors - lighter versions */
            --short-color: #90CAF9;     /* Light Blue */
            --medium-color: #A5D6A7;    /* Light Green */
            --long-color: #FFCC80;      /* Light Orange */
            --extra-long-color: #F48FB1; /* Light Pink */
            --paragraph-color: rgba(0, 0, 0, 0.1); /* Transparent */
            --gradient-border: linear-gradient(90deg, #5D5CDE, #9C27B0);
            --flat-black: #181818;
            --white: #FFFFFF;
            --light-grey: #e5e5e5;
            --toggle-green: #10B981; /* Green color for toggle */
        }
        
    
    /* Oval tab styling with gradient effects */
    .oval-tab {
        position: relative;
        border: 2px solid transparent !important;
        background: linear-gradient(var(--white), var(--white)) padding-box,
                    var(--gradient-border) border-box !important;
        transition: all 0.3s ease-out !important;
        z-index: 1;
        overflow: visible !important;
    }
    
    .oval-tab::after {
        content: '';
        position: absolute;
        right: -3px;
        top: -2px;
        left: -3px;
        bottom: -2px;
        border-radius: 999px;
        background: var(--gradient-border);
        filter: blur(6px);
        opacity: 0;
        transition: opacity ease-out 0.3s;
        z-index: -1;
    }
    
    .oval-tab:hover {
        border-width: 3px !important;
    }
    
    .oval-tab:hover::after {
        opacity: 0.7;
    }
    
    .oval-tab.active {
        border-width: 3px !important;
        box-shadow: 0 2px 10px rgba(93, 92, 222, 0.3);
    }
    
    .oval-tab.active::after {
        opacity: 0.7;
    }
    
    html.dark .oval-tab {
        background: linear-gradient(rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.1)) padding-box,
                    var(--gradient-border) border-box !important;
        color: var(--white);
    }
    
    /* Analyze button styling with gradient effects */
    .analyze-btn,
    #analyzeBtn,
    #analyzeHomonymBtn,
    #analyzeRhythmBtn {
        position: relative;
        border: 2px solid transparent !important;
        background: linear-gradient(var(--primary), var(--primary)) padding-box,
                    var(--gradient-border) border-box !important;
        transition: all 0.3s ease-out !important;
        z-index: 1;
        overflow: visible !important;
    }
    
    .analyze-btn::after,
    #analyzeBtn::after,
    #analyzeHomonymBtn::after,
    #analyzeRhythmBtn::after {
        content: '';
        position: absolute;
        right: -3px;
        top: -2px;
        left: -3px;
        bottom: -2px;
        border-radius: 999px;
        background: var(--gradient-border);
        filter: blur(6px);
        opacity: 0;
        transition: opacity ease-out 0.3s;
        z-index: -1;
    }
    
    .analyze-btn:hover,
    #analyzeBtn:hover,
    #analyzeHomonymBtn:hover,
    #analyzeRhythmBtn:hover {
        border-width: 3px !important;
        transform: translateY(-1px);
    }
    
    .analyze-btn:hover::after,
    #analyzeBtn:hover::after,
    #analyzeHomonymBtn:hover::after,
    #analyzeRhythmBtn:hover::after {
        opacity: 1;
    }
    
    .analyze-btn:active,
    #analyzeBtn:active,
    #analyzeHomonymBtn:active,
    #analyzeRhythmBtn:active {
        transform: translateY(1px);
    }
    
    /* Phonetic tab group styling */
    .phonetic-group .oval-tab,
    .language-analysis-group .oval-tab {
        margin-top: 12px;
    }
    
    .phonetic-bracket-label,
    .language-analysis-bracket-label {
        z-index: 2;
    }
    
    
    .phonetic-label-text,
    .language-analysis-label-text {
        background: linear-gradient(90deg, #5D5CDE, #9C27B0);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        font-weight: 600;
        padding: 0 8px;
    }
    
    html.dark .phonetic-label-text,
    html.dark .language-analysis-label-text {
        background: linear-gradient(90deg, #8281E6, #BB6BD9);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
    }
        /* Style for Letter % Match error */
        .letter-match-error {
            color: #e53e3e;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        /* Add RTL text support */
        [dir="auto"] {
            unicode-bidi: plaintext;
            text-align: start;
        }
        
        /* Dark theme icon colors */
        html.dark #darkThemeBtn svg,
        html.dark #undoBtn svg,
        html.dark #redoBtn svg {
            color: black;
        }
        
        /* Modified countdown timer to display inline */
        .countdown-timer {
            color: white;
            font-size: 16px;
            font-weight: bold;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px;
            animation: pulse 1s infinite;
        }
        
        .countdown-timer-4 {
            background-color: var(--short-color); /* Blue */
        }
        
        .countdown-timer-3 {
            background-color: var(--medium-color); /* Green */
        }
        
        .countdown-timer-2 {
            background-color: var(--long-color); /* Orange */
        }
        
        .countdown-timer-1 {
            background-color: var(--extra-long-color); /* Pink */
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Add min-width to distribution bar sections */
        .w-full.h-10.flex.rounded-lg.overflow-hidden > div {
            min-width: 35px;
        }
    
        /* Default light theme styles */
        body {
            background-color: var(--light-bg);
            color: var(--light-text);
        }
        .tab, .results {
            background-color: rgba(0, 0, 0, 0.03);
            border-color: var(--light-border);
        }
        .text-editor {
            background-color: var(--light-bg);
            border: none;
        }
        .tab.active {
            background-color: var(--primary);
            color: white;
        }
        .highlight {
            background-color: var(--primary-light);
            color: white;
        }
        input[type="radio"] + label, input[type="checkbox"] + label {
            color: var(--light-text);
        }
        .custom-set-item {
            background-color: rgba(0, 0, 0, 0.02);
            border-color: var(--light-border);
        }
        .custom-set-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        .metrics-panel {
            background-color: rgba(0, 0, 0, 0.02);
            border-color: var(--light-border);
            border-radius: 20px; /* Make metrics container more oval */
            overflow: hidden;
        }
    
        /* Dark theme styles - directly applied when .dark class exists */
        html.dark {
            --paragraph-color: rgba(255, 255, 255, 0.1);
        }
        
        html.dark body {
            background-color: var(--dark-bg);
            color: var(--dark-text);
        }
        html.dark .tab, 
        html.dark .results {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: var(--dark-border);
        }
        html.dark .text-editor {
            background-color: var(--dark-bg);
            border: none;
        }
        html.dark .tab.active {
            background-color: var(--primary);
            color: white;
        }
        html.dark .highlight {
            background-color: var(--primary-dark);
            color: white;
        }
        html.dark input[type="radio"] + label, 
        html.dark input[type="checkbox"] + label {
            color: var(--dark-text);
        }
        html.dark .custom-set-item {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: var(--dark-border);
        }
        html.dark .custom-set-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        html.dark .metrics-panel {
            background-color: rgba(255, 255, 255, 0.05);
            border-color: var(--dark-border);
        }
        html.dark .bg-gray-100 {
            background-color: var(--dark-bg);
        }
        html.dark .text-gray-600 {
            color: #d1d5db;
        }
        
        /* Ensure light theme is applied correctly when manually selected */
        html:not(.dark) body {
            background-color: var(--light-bg) !important;
            color: var(--light-text) !important;
        }
        html:not(.dark) .bg-gray-100 {
            background-color: #F3F4F6 !important;
        }
        html:not(.dark) .text-gray-600 {
            color: #4B5563 !important;
        }
        html:not(.dark) .dark\:bg-gray-700, 
        html:not(.dark) .dark\:bg-gray-800 {
            background-color: #F9FAFB !important;
        }
        html:not(.dark) .dark\:text-gray-400,
        html:not(.dark) .dark\:text-gray-300 {
            color: #4B5563 !important;
        }
        
        /* Fix dark theme button visibility when system is dark */
        @media (prefers-color-scheme: dark) {
            #systemThemeBtn.active + #darkThemeBtn svg,
            html.dark #darkThemeBtn svg {
                color: white !important;
            }
        }
        
        /* Improved styling for bar size toggle */
        /* Improved styling for bar size toggle */
        html:not(.dark) .bar-size-btn.active {
            background-color: var(--primary) !important;
            color: white !important;
            border-color: var(--primary) !important;
        }
        
        html.dark .bar-size-btn.active {
            background-color: var(--primary) !important;
            color: white !important;
            border-color: var(--primary) !important;
        }
        
        /* Make sure the moon icon (dark theme button) is always visible in system dark theme */
        @media (prefers-color-scheme: dark) {
            #darkThemeBtn svg {
                color: white !important;
            }
        }
    
        @media (prefers-color-scheme: light) {
            body {
                background-color: var(--light-bg);
                color: var(--light-text);
            }
            .tab, .text-editor, .results {
                
                border-color: var(--light-border);
            }
            .tab.active {
                background-color: var(--primary);
                color: white;
            }
            .highlight {
                background-color: var(--primary-light);
                color: white;
            }
            input[type="radio"] + label, input[type="checkbox"] + label {
                color: var(--light-text);
            }
            .custom-set-item {
                background-color: rgba(0, 0, 0, 0.02);
                border-color: var(--light-border);
            }
            .custom-set-item:hover {
                background-color: rgba(0, 0, 0, 0.05);
            }
            .metrics-panel {
                background-color: rgba(0, 0, 0, 0.02);
                border-color: var(--light-border);
            }
        }
    
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        
        /* Editor Tabs */
        .editor-tab {
            cursor: pointer;
            border-bottom: 2px solid transparent;
            padding: 0.5rem 1rem;
            font-weight: 500;
        }
        
        .editor-tab.active {
            border-bottom-color: #5D5CDE;
            color: #5D5CDE;
        }
        
        .editor-content {
            display: none;
        }
        
        .editor-content.active {
            display: block;
        }
        
        /* Rainbow colors for pronouns */
        .highlight-i { background-color: #FF0000; color: white; } /* Red */
        .highlight-you { background-color: #FF7F00; color: white; } /* Orange */
        .highlight-it { background-color: #FFFF00; color: black; } /* Yellow */
        .highlight-he { background-color: #00FF00; color: black; } /* Green */
        .highlight-she { background-color: #0000FF; color: white; } /* Blue */
        .highlight-we { background-color: #4B0082; color: white; } /* Indigo */
        .highlight-they { background-color: #9400D3; color: white; } /* Violet */
        
        /* Adverbs and passive voice styles */
        .highlight-adverb { background-color: #10B981; color: white; } /* Emerald green */
        .highlight-passive { background-color: #3B82F6; color: white; } /* Light blue */
        
        /* Word density styles */
        .highlight-density { background-color: var(--density-highlight); color: white; }
        .word-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            border-bottom: 1px solid var(--light-border);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .word-item:hover {
            background-color: rgba(156, 39, 176, 0.1);
        }
        .word-item.active {
            background-color: rgba(156, 39, 176, 0.2);
            font-weight: 500;
        }
        
        /* Location buttons - Updated to match tabs/oval-tab style completely */
        .location-button, 
        .homonym-location-button {
            position: relative;
            border: 2px solid transparent !important;
            background: linear-gradient(var(--white), var(--white)) padding-box,
                        var(--gradient-border) border-box !important;
            transition: all 0.3s ease-out !important;
            z-index: 1;
            overflow: visible !important;
            border-radius: 999px !important;
            font-weight: normal;
            color: black !important;
        }
    
        .location-button::after,
        .homonym-location-button::after {
            content: '';
            position: absolute;
            right: -3px;
            top: -2px;
            left: -3px;
            bottom: -2px;
            border-radius: 999px;
            background: var(--gradient-border);
            filter: blur(6px);
            opacity: 0;
            transition: opacity ease-out 0.3s;
            z-index: -1;
        }
        
        .location-button:hover,
        .homonym-location-button:hover {
            border-width: 3px !important;
            transform: translateY(-1px);
        }
        
        .location-button:hover::after,
        .homonym-location-button:hover::after {
            opacity: 0.7;
        }
        
        html.dark .location-button, 
        html.dark .homonym-location-button {
            background: linear-gradient(rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.1)) padding-box,
                        var(--gradient-border) border-box !important;
            color: white !important;
        }
        
        .location-button.active,
        .homonym-location-button.active {
            background: linear-gradient(var(--primary), var(--primary)) padding-box,
                       var(--gradient-border) border-box !important;
            color: white !important;
            border-width: 3px !important;
            box-shadow: 0 2px 10px rgba(93, 92, 222, 0.3);
        }
        
        .location-button.active::after,
        .homonym-location-button.active::after {
            opacity: 0.7;
        }
        
        /* Toggle switch custom styling */
        input[type="checkbox"].peer:checked + div.peer-checked\:bg-indigo-600 {
            background-color: var(--toggle-green) !important;
        }
        
        /* Ensure Sound Pattern Location buttons have proper text color in light and dark mode */
        .homonym-location-button {
            color: black !important;
        }
        html.dark .homonym-location-button {
            color: white !important;
        }
        .homonym-location-button.active {
            color: white !important;
        }
        .letter-highlight {
            background-color: var(--letter-highlight);
            color: black;
            border-radius: 0.25rem;
        }
        
        /* Stats list */
        .stats-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }
        .stats-list li {
            display: flex;
            justify-content: space-between;
            padding: 6px 10px;
            border-bottom: 1px solid var(--light-border);
        }
        .stats-list li:last-child {
            border-bottom: none;
        }
        .stats-list .item-count {
            font-weight: 500;
        }
        .stats-header {
            font-weight: 600;
            border-bottom: 2px solid var(--light-border);
            padding: 6px 10px;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }
        
        /* Form error styling */
        .form-error {
            color: #e53e3e;
            font-size: 0.75rem;
            margin-top: 0.25rem;
        }
        
        .error-border {
            border-color: #e53e3e !important;
        }
        
        /* Results display */
        #resultsDisplay {
            white-space: pre-wrap;
        }
        
        /* Custom Sets styles */
        .custom-set-item {
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.75rem;
            border-width: 1px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .custom-set-item.active {
            border-left-width: 4px;
        }
        .color-swatch {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
            border: 1px solid rgba(0,0,0,0.1);
        }
        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            margin: 3px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .color-option.selected {
            transform: scale(1.2);
            border-color: #fff;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
        }
        
        /* Tab controls with analyze button */
        .tab-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        
        /* Warning alert inside tab header */
        .tab-warning {
            background-color: #FEF2F2;
            border: 1px solid #FCA5A5;
            color: #991B1B;
            font-size: 0.875rem;
            padding: 0.5rem;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            width: 100%;
            display: flex;
            align-items: center;
        }
        
        .tab-warning.warning-red {
            color: var(--warning-text);
            font-weight: 500;
        }
        
        @media (prefers-color-scheme: dark) {
            .tab-warning {
                background-color: #7F1D1D;
                border-color: #B91C1C;
                color: #FECACA;
            }
        }
        
        /* Configuration changed alert */
        .config-changed-alert {
            display: none;
        }
        
        /* Stats container */
        .stats-container {
            margin-top: 1rem;
            padding: 1rem;
            border: 1px solid var(--light-border);
            border-radius: 0.375rem;
            background-color: var(--light-bg);
        }
        
        @media (prefers-color-scheme: dark) {
            .stats-container {
                background-color: rgba(255, 255, 255, 0.05);
                border-color: var(--dark-border);
            }
        }
        
        /* Metrics panel */
        .metrics-panel {
            border-radius: 20px;
            border-width: 1px;
            margin-top: 0.75rem;
            overflow: hidden;
        }
        
        .metrics-header {
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
            color: black;
            background-color: lavender;
        }
        
        .metrics-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .metrics-content.expanded {
            max-height: 200px;
        }
        
        .chevron {
            transition: transform 0.3s ease;
        }
        
        .chevron.rotated {
            transform: rotate(180deg);
        }
    
        /* Updated Rhythm tab styles */
        #rhythm-container {
            position: relative;
            margin-top: 1rem;
            overflow-x: auto;
            min-height: 200px;
            padding: 10px 0;
        }
        
        /* Move the legend below the chart */
        #rhythm-legend {
            margin-top: 1rem;
            justify-content: center;
        }
    
        #rhythm-legend {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }
    
        .rhythm-legend-item {
            display: flex;
            align-items: center;
            font-size: 0.875rem;
        }
    
        .rhythm-color-indicator {
            display: inline-block;
            width: 16px;
            height: 16px;
            margin-right: 6px;
            border-radius: 2px;
            border: 1px solid rgba(0,0,0,0.1);
        }
    
        #sentence-chart {
            display: flex;
            align-items: flex-end;
            min-height: 150px;
            gap: 4px; /* Increased gap between bars */
        }
    
        .rhythm-bar {
            width: var(--rhythm-bar-width, 11px); /* Use variable with fallback */
            min-width: var(--rhythm-bar-width, 11px); /* Use variable with fallback */
            cursor: pointer;
            border-radius: 2px 2px 0 0;
            transition: transform 0.2s ease;
            position: relative;
        }
    
        .rhythm-bar:hover {
            transform: scaleY(1.05);
        }
        
        /* Set bar colors with max heights */
        .rhythm-bar-short {
            background-color: var(--short-color);
            min-height: 15px;
            max-height: 40px;
        }
    
        .rhythm-bar-medium {
            background-color: var(--medium-color);
            min-height: 45px;
            max-height: 70px;
        }
    
        .rhythm-bar-long {
            background-color: var(--long-color);
            min-height: 75px;
            max-height: 100px;
        }
    
        .rhythm-bar-extralong {
            background-color: var(--extra-long-color);
            min-height: 105px;
            max-height: 125px;
        }
    
        .rhythm-bar-paragraph {
            background-color: var(--paragraph-color);
            height: 10px !important;
            margin-top: auto;
        }
        
        /* Set legend colors */
        .legend-short {
            background-color: var(--short-color);
        }
        
        .legend-medium {
            background-color: var(--medium-color);
        }
        
        .legend-long {
            background-color: var(--long-color);
        }
        
        .legend-extralong {
            background-color: var(--extra-long-color);
        }
        
        .legend-paragraph {
            background-color: var(--paragraph-color);
            border: 1px dashed rgba(0,0,0,0.3);
        }
    
        /* Tooltip for rhythm bars - improved positioning and visibility */
        .rhythm-tooltip {
            position: absolute;
            top: -30px; /* Fixed position at the top */
            left: 10px; /* Offset to the right side of the bar */
            padding: 4px 8px;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            white-space: nowrap;
            z-index: 99999 !important; /* Extremely high z-index with !important */
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.2s, visibility 0.2s;
            pointer-events: none;
            max-width: 200px;
            text-overflow: ellipsis;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Force tooltip to the foreground */
        .rhythm-bar:hover {
            transform: scaleY(1.05);
            z-index: 99990 !important; /* Ensure bar gets high z-index when hovered */
        }
    
        /* Ensure tooltip is always visible */
        .rhythm-bar:hover .rhythm-tooltip {
            visibility: visible;
            opacity: 1;
        }
    
        /* Sentence highlight colors matching bar colors */
        .highlight-sentence-short {
            background-color: rgba(144, 202, 249, 0.4);
            animation: fadeSentenceHighlight 2.5s forwards;
        }
    
        .highlight-sentence-medium {
            background-color: rgba(165, 214, 167, 0.4);
            animation: fadeSentenceHighlight 2.5s forwards;
        }
    
        .highlight-sentence-long {
            background-color: rgba(255, 204, 128, 0.4);
            animation: fadeSentenceHighlight 2.5s forwards;
        }
    
        .highlight-sentence-extralong {
            background-color: rgba(244, 143, 177, 0.4);
            animation: fadeSentenceHighlight 2.5s forwards;
        }
        
        /* Default highlight for backward compatibility */
        .highlight-sentence {
            background-color: rgba(93, 92, 222, 0.3);
            animation: fadeSentenceHighlight 2.5s forwards;
        }
    
        @keyframes fadeSentenceHighlight {
            0% {
                opacity: 1;
            }
            80% {
                opacity: 1;
            }
            100% {
                opacity: 0;
            }
        }
        
        /* Matches result styles */
        .match-result {
            transition: all 0.2s ease;
        }
        
        .match-result:hover {
            background-color: rgba(156, 39, 176, 0.1) !important; /* Purple highlight matching Density tab */
        }
        
        /* Dark mode specific hover styles */
        html.dark .match-result:hover {
            background-color: rgba(156, 39, 176, 0.15) !important; /* Slightly brighter for dark mode */
        }
    
        /* Fix for Quill editor */
        .ql-container {
            font-size: 16px;
            border: none !important;
            background-color: transparent !important;
        }
        .ql-editor {
            min-height: 200px;
            max-height: 300px;
            background-color: inherit !important;
            border: none !important;
        }
        .ql-toolbar {
            border: none !important;
            background-color: lavender;
            border-radius: 8px;
        }
        
        /* Custom RTL button styles */
        .ql-rtl {
            width: 28px !important;
            height: 24px !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        .ql-rtl svg {
            width: 18px;
            height: 18px;
        }
        
        .ql-rtl.ql-active {
            color: #06c !important;
        }
        
        /* RTL styling for the editor */
        .ql-editor[dir="rtl"] {
            text-align: right;
        }
        
        /* Custom styling for undo/redo buttons in Quill toolbar */
        .ql-undo, .ql-redo {
            position: relative;
            width: 28px !important;
            height: 24px !important;
            display: flex !important;
            color: black !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        .ql-undo:after, .ql-redo:after {
            font-family: sans-serif;
            font-size: 14px;
            font-weight: bold;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .ql-undo:after {
            content: "↶";
        }
        
        .ql-redo:after {
            content: "↷";
        }
        
        .ql-undo.ql-active, .ql-redo.ql-active {
            color: #06c !important;
        }
        
        /* NEW STYLES FOR THE UPDATED DESIGN */
        
        /* Oval tabs styling */
        .tabs-container {
            margin-bottom: 0.5rem !important; /* CHANGED: from 20px (1.25rem) to 0.5rem */
        }
        
        .oval-tab {
            border-radius: 999px !important; /* Full oval shape */
            padding: 0.5rem 1.25rem !important;
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease;
            background-color: #f3f4f6 !important;
            border: none !important;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        html.dark .oval-tab {
            background-color: rgba(255, 255, 255, 0.1) !important;
        }
        
        .oval-tab:hover {
            background-color: #e5e7eb !important;
        }
        
        html.dark .oval-tab:hover {
            background-color: rgba(255, 255, 255, 0.15) !important;
        }
        
        .oval-tab.active {
            background-color: var(--primary) !important;
            color: white !important;
            box-shadow: 0 2px 4px rgba(93, 92, 222, 0.3);
        }
        
        /* Phonetic tabs styling */
        .phonetic-group,
        .language-analysis-group {
            position: relative;
            margin-top: 12px;
        }
        
        .phonetic-bracket-label,
        .language-analysis-bracket-label {
            position: absolute;
            top: -24px;
            left: 0;
            right: 0;
            text-align: center;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--primary);
        }
        
        
        .phonetic-label-text,
        .language-analysis-label-text {
            position: relative;
            padding: 0 8px;
            background-color: var(--light-bg);
            z-index: 1;
        }
        
        html.dark .phonetic-label-text,
        html.dark .language-analysis-label-text {
            background-color: var(--dark-bg);
        }
        
        .phonetic-tab {
            margin-top: 8px;
        }
        
        .phonetic-bracket-spacer {
            width: 30px;
            height: 1px;
        }
        
        /* Oval analyze buttons */
        .analyze-btn,
        #analyzeBtn,
        #analyzeHomonymBtn,
        #analyzeRhythmBtn {
            border-radius: 999px !important;
            padding-left: 1.25rem !important;
            padding-right: 1.25rem !important;
            transition: all 0.2s ease;
        }
        
        /* Tab content styling - disconnected from tabs */
        .tab-content {
            border-radius: 12px !important;
            margin-top: 8px !important;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        
        html.dark .tab-content {
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
    
        /* CHANGE: Modified header margin */
        .flex.justify-between.items-center.mb-6 {
            margin-bottom: 0.5rem !important;
        }
    
        /* Language Analysis group - adding styling similar to Phonetic group */
        .language-analysis-group .oval-tab {
            margin-top: 8px;
        }
    
        .language-analysis-bracket-spacer {
            width: 30px;
            height: 1px;
        }
    </style>
</head>
<body class="min-h-screen font-sans p-4">
    <div class="max-w-4xl mx-auto">
        <div class="flex justify-between items-center mb-6">
            <h1 class="text-3xl font-bold">Beampen Writing Lab</h1>
            <div class="flex items-center">
                <!-- Export buttons -->
                <div class="export-buttons flex space-x-1 mr-4">
                    <button id="exportTxtBtn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700" title="Export as TXT (Plain Text)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="9" y1="15" x2="15" y2="15"></line>
                        </svg>
                        <span class="text-xs">TXT</span>
                    </button>
                    <button id="exportRtfBtn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700" title="Export as RTF (Rich Text - Recommended)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                            <polyline points="14 2 14 8 20 8"></polyline>
                            <line x1="9" y1="13" x2="15" y2="13"></line>
                            <line x1="9" y1="17" x2="15" y2="17"></line>
                        </svg>
                        <span class="text-xs">RTF</span>
                    </button>

                </div>
                
                <!-- Copy button -->
                <button id="copyTextBtn" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 mr-2" title="Copy text without colors">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                        <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                </button>
                
                <!-- Theme toggle buttons -->
                <div class="theme-toggle flex space-x-2">
                    <button id="lightThemeBtn" class="p-2 rounded-full" title="Light Theme">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
                        </svg>
                    </button>
                    <button id="darkThemeBtn" class="p-2 rounded-full" title="Dark Theme">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
                        </svg>
                    </button>
                    <button id="systemThemeBtn" class="p-2 rounded-full" title="System Theme">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" />
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Text Editor - Always on top -->
        <div class="text-editor mb-4 p-3 rounded-lg border">
            <!-- Quill Editor area -->
            <div id="editorArea" class="editor-content active">
                <div id="quill-toolbar" class="mb-2">
                    <!-- Quill will create the toolbar here -->
                </div>
                <div id="quill-editor" class="rounded-lg border" style="min-height: 200px; max-height: 300px; overflow-y: auto;"></div>
            </div>
            
            <!-- Collapsible Metrics Panel -->
            <div class="metrics-panel">
                <div class="metrics-header py-1 px-2" id="metricsToggle">
                    <div class="flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        Metrics
                    </div>
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 chevron rotated" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
                    </svg>
                </div>
                <div class="metrics-content expanded" id="metricsContent">
                    <div class="grid grid-cols-2 sm:grid-cols-6 gap-1 p-1 text-sm">
                        <div class="bg-gray-100 dark:bg-gray-800 p-1 rounded relative">
                            <div class="font-medium">Words</div>
                            <div id="wordCount" class="text-lg">0</div>
                        </div>
                        <div class="bg-gray-100 dark:bg-gray-800 p-1 rounded relative">
                            <div class="font-medium">Characters</div>
                            <div id="charCount" class="text-lg">0</div>
                        </div>
                        <div class="bg-gray-100 dark:bg-gray-800 p-1 rounded relative">
                            <div class="font-medium">Chars with spaces</div>
                            <div id="charWithSpacesCount" class="text-lg">0</div>
                        </div>
                        <div class="bg-gray-100 dark:bg-gray-800 p-1 rounded relative">
                            <div class="font-medium">Paragraphs</div>
                            <div id="paragraphCount" class="text-lg">0</div>
                        </div>
                        <div class="bg-gray-100 dark:bg-gray-800 p-1 rounded relative">
                            <div class="font-medium">Sentences</div>
                            <div id="sentenceCount" class="text-lg">0</div>
                        </div>
                        <div class="bg-gray-100 dark:bg-gray-800 p-1 rounded relative">
                            <div class="font-medium">Reading time</div>
                            <div id="readingTime" class="text-lg">0 min</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Tab Navigation - Rearranged and styled as ovals, all on one row -->
        <div class="tabs-container mb-6 relative">
            <div class="flex flex-wrap items-end gap-2">
                <!-- Main Tabs -->
                <button class="oval-tab tab-link active" data-tab="densityTab">Density</button>
                <button class="oval-tab tab-link" data-tab="pronounsTab">POS & Voice</button>
                <button class="oval-tab tab-link" data-tab="customSetsTab">Custom Sets</button>
                
                <!-- Phonetic Pattern Tabs - positioned lower with the bracket above -->
                <div class="phonetic-group relative">
                    <button class="oval-tab tab-link phonetic-tab" data-tab="homonymPatternsTab">Homonyms</button>
                    <button class="oval-tab tab-link phonetic-tab" data-tab="homophonesTab">Letters</button>
                    
                    <!-- Phonetic Patterns label with bracket -->
                    <div class="phonetic-bracket-label">
                        <span class="phonetic-label-text">Phonetic Patterns</span>
                    </div>
                </div>
                
                <!-- Rhythm Tab (moved to the end) -->
                <button class="oval-tab tab-link" data-tab="rhythmTab">Rhythm</button>
            </div>
        </div>
        
        <!-- Tab Contents with Analyze button in top-right corner -->
        <div class="tab-contents">
            <!-- Density Tab -->
            <div id="densityTab" class="tab-content p-4 rounded-lg border active">
                <div class="tab-header">
                    <h3 class="text-lg font-semibold">Word Density Analysis</h3>
                    <button class="analyze-btn bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-full">Analyze</button>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div class="md:col-span-1">
                        <div class="border rounded-lg p-3 dark:bg-gray-800" style="height: 230px;">
                            <h4 class="font-medium mb-2 text-center">Most Used Words</h4>
                            <div id="wordList" class="h-[190px] overflow-y-auto">
                                <div class="text-center text-gray-500 italic">Click Analyze to see results</div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="md:col-span-2">
                        <div class="border rounded-lg p-3 dark:bg-gray-800">
                            <div class="mb-4">
                                <div class="flex flex-row items-center justify-between mb-2">
                                    <h4 class="font-medium">Word Similarity Threshold</h4>
                                    <div class="flex items-center">
                                        <input type="checkbox" id="includeDerivatives">
                                        <label for="includeDerivatives" class="ml-2 text-sm">Exact words</label>
                                    </div>
                                </div>
                                <div class="flex items-center mb-2">
                                    <input type="range" id="similarityThreshold" min="50" max="90" value="70" class="w-full">
                                    <span id="thresholdValue" class="ml-2 text-sm font-medium">70%</span>
                                </div>
                                
                                <div class="flex justify-between text-sm text-gray-600 dark:text-gray-400 mb-4">
                                    <p>Lower: less similar</p>
                                    <p>Higher: more similar</p>
                                </div>
                                
                                <!-- Analysis mode for different language types -->
                                <div class="mb-3 border-b border-gray-200 dark:border-gray-700 pb-3">
                                    <div class="font-medium mb-2 text-sm">Analysis Mode</div>
                                    <div class="flex gap-4 flex-wrap">
                                        <div class="flex items-center">
                                            <input type="radio" id="analysisWords" name="analysisMode" value="words" checked>
                                            <label for="analysisWords" class="ml-2 text-sm">Words (Default)</label>
                                        </div>
                                        <div class="flex items-center">
                                            <input type="radio" id="analysisCJK" name="analysisMode" value="cjk">
                                            <label for="analysisCJK" class="ml-2 text-sm">CJKT (Chinese, Japanese, Korean, Thai)</label>
                                        </div>
                                        <div class="flex items-center">
                                            <input type="radio" id="analysisSymbols" name="analysisMode" value="symbols">
                                            <label for="analysisSymbols" class="ml-2 text-sm">Symbols (Character-by-character)</label>
                                        </div>
                                    </div>
                                    <div id="cjk-detection-message" class="hidden mt-2 text-xs text-blue-500 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/30 p-2 rounded-md flex items-center">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1 inline" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                                        </svg>
                                        <span>CJK text detected. Using Intl.Segmenter for accurate word segmentation.</span>
                                    </div>
                                </div>
                                
                                <div class="flex items-center mb-2">
                                    <input type="checkbox" id="excludeCommonWords" checked>
                                    <label for="excludeCommonWords" class="ml-2 text-sm">Exclude common words (pronouns, the, a, and, etc.)</label>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- POS and Passive Voice Tab (previously Pronouns Tab) -->
            <div id="pronounsTab" class="tab-content p-4 rounded-lg border">
                <div class="tab-header">
                    <h3 class="text-lg font-semibold">Parts of Speech & Passive Voice</h3>
                        <div class="flex items-center space-x-3">
                        <!-- No elements found warning - single line with icon -->
                        <div id="noElementsWarning" class="hidden flex items-center text-red-600 dark:text-red-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            <span class="text-sm">No matches found</span>
                        </div>
                        <button class="analyze-btn bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-full">Analyze</button>
                    </div>
                </div>
                
                <!-- Category selection controls -->
                <div class="mb-6 border-b pb-4 border-gray-200 dark:border-gray-700">
                    <div class="flex flex-wrap gap-3">
                        <div class="flex items-center">
                            <input type="checkbox" id="enablePronouns">
                            <label for="enablePronouns" class="ml-2 font-semibold text-indigo-600 dark:text-indigo-400">Pronouns</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="enableAdverbs" checked>
                            <label for="enableAdverbs" class="ml-2 font-semibold text-emerald-600 dark:text-emerald-400">Adverbs</label>
                        </div>
                        <div class="flex items-center">
                            <input type="checkbox" id="enablePassiveVoice" checked>
                            <label for="enablePassiveVoice" class="ml-2 font-semibold text-amber-600 dark:text-amber-400">Passive Voice</label>
                        </div>
                    </div>
                </div>
                
                <!-- Pronouns Section -->
                <div id="pronounsSection" class="mb-6">
                    <h4 class="font-medium mb-3">Pronouns</h4>
                    <div class="flex flex-wrap gap-3 mb-4">
                        <div class="flex items-center">
                            <input type="checkbox" id="highlightI" name="pronouns" value="i" checked>
                            <label for="highlightI" class="ml-2">
                                <span class="highlight-i px-3 py-1 rounded inline-block text-center font-medium">I</span>
                            </label>
                        </div>
                        
                        <div class="flex items-center">
                            <input type="checkbox" id="highlightYou" name="pronouns" value="you" checked>
                            <label for="highlightYou" class="ml-2">
                                <span class="highlight-you px-3 py-1 rounded inline-block text-center font-medium">You</span>
                            </label>
                        </div>
                        
                        <div class="flex items-center">
                            <input type="checkbox" id="highlightIt" name="pronouns" value="it" checked>
                            <label for="highlightIt" class="ml-2">
                                <span class="highlight-it px-3 py-1 rounded inline-block text-center font-medium">It</span>
                            </label>
                        </div>
                        
                        <div class="flex items-center">
                            <input type="checkbox" id="highlightHe" name="pronouns" value="he" checked>
                            <label for="highlightHe" class="ml-2">
                                <span class="highlight-he px-3 py-1 rounded inline-block text-center font-medium">He</span>
                            </label>
                        </div>
                        
                        <div class="flex items-center">
                            <input type="checkbox" id="highlightShe" name="pronouns" value="she" checked>
                            <label for="highlightShe" class="ml-2">
                                <span class="highlight-she px-3 py-1 rounded inline-block text-center font-medium">She</span>
                            </label>
                        </div>
                        
                        <div class="flex items-center">
                            <input type="checkbox" id="highlightWe" name="pronouns" value="we" checked>
                            <label for="highlightWe" class="ml-2">
                                <span class="highlight-we px-3 py-1 rounded inline-block text-center font-medium">We</span>
                            </label>
                        </div>
                        
                        <div class="flex items-center">
                            <input type="checkbox" id="highlightThey" name="pronouns" value="they" checked>
                            <label for="highlightThey" class="ml-2">
                                <span class="highlight-they px-3 py-1 rounded inline-block text-center font-medium">They</span>
                            </label>
                        </div>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400">For other languages, use Custom Sets tab</p>
                </div>
                
                <!-- Adverbs Section -->
                <div id="adverbsSection" class="mb-6 hidden">
                    <h4 class="font-medium mb-3">Adverbs</h4>
                    <div class="flex items-center mb-4">
                        <div class="inline-block px-3 py-1 rounded bg-emerald-500 text-white font-medium mr-3">-ly</div>
                        <span>Highlights adverbs (primarily those ending in -ly)</span>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400">Common adverbs like "very", "too", "so", etc. are also detected</p>
                </div>
                
                <!-- Passive Voice Section -->
                <div id="passiveVoiceSection" class="mb-6 hidden">
                    <h4 class="font-medium mb-3">Passive Voice</h4>
                    <div class="flex items-center mb-4">
                        <div class="inline-block px-3 py-1 rounded bg-blue-500 text-white font-medium mr-3">Passive</div>
                        <span>Highlights passive voice constructions</span>
                    </div>
                    <p class="text-sm text-gray-600 dark:text-gray-400">Detects forms like "is/was/were [adverb] done" and similar patterns</p>
                </div>
                
                <!-- Stats container for results -->
                <div id="posStatsContainer" class="hidden stats-container">
                    <div class="stats-header">
                        <span>Category</span>
                        <span>Count</span>
                    </div>
                    <ul id="posStatsList" class="stats-list">
                        <!-- Will be populated by JavaScript -->
                    </ul>
                    <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                        <div class="flex justify-between font-medium">
                            <span>Total matches:</span>
                            <span id="totalPosMatches">0</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Custom Sets Tab -->
            <div id="customSetsTab" class="tab-content p-4 rounded-lg border">
                <div class="tab-header">
                    <div class="flex items-center">
                        <h3 class="text-lg font-semibold">Custom Word Sets</h3>
                        <div id="noActiveSetsWarning" class="hidden flex items-center ml-3 text-red-600 dark:text-red-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            <span>Select at least one active set.</span>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <!-- No matches found warning -->
                        <div id="noCustomMatchesWarning" class="hidden flex items-center text-red-600 dark:text-red-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            <span class="text-sm">No matches found</span>
                        </div>
                        <button class="analyze-btn bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-full">Analyze</button>
                    </div>
                </div>
                
                <p class="mb-4 text-gray-600 dark:text-gray-300">Perfect for analyzing specific patterns in multilingual texts.<br>Use case: Pronouns and all their forms in any language</p>
                
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Left column: Custom sets list -->
                    <div class="md:col-span-1">
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-medium">Your Sets</h4>
                            <button id="createSetBtn" class="text-white bg-indigo-600 hover:bg-indigo-700 px-3 py-1 rounded-full text-sm">+ New Set</button>
                        </div>
                        
                        <div id="customSetsList" class="border rounded-lg p-4 dark:bg-gray-800 mb-3 min-h-[220px] max-h-[300px] overflow-y-auto">
                            <!-- Sample set item (will be generated by JS) -->
                            <div class="text-center text-gray-500 dark:text-gray-400 italic">No custom sets yet</div>
                        </div>
                        
                        <div class="flex space-x-2">
                            <button id="exportSetsBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded-full text-sm flex-1">Export</button>
                            <button id="importSetsBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded-full text-sm flex-1">Import</button>
                        </div>
                    </div>
                    
                    <!-- Right column: Edit form / Preview -->
                    <div class="md:col-span-2">
                        <!-- Set edit form -->
                        <div id="setEditForm" class="border rounded-lg p-4 dark:bg-gray-800 mb-4">
                            <h4 class="font-medium mb-3">Create/Edit Set</h4>
                            
                            <div class="mb-3">
                                <label for="setName" class="block text-sm font-medium mb-1">Set Name</label>
                                <input type="text" id="setName" class="w-full p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base" placeholder="e.g. Spanish Pronoun Yo">
                            </div>
                            
                            <div class="mb-3">
                                <label class="block text-sm font-medium mb-1">Set Color</label>
                                <div id="colorPicker" class="flex flex-wrap mb-2">
                                    <!-- Color options will be added via JS -->
                                </div>
                            </div>
                            
                            <div class="mb-3">
                                <label for="setWords" class="block text-sm font-medium mb-1">Words to Highlight</label>
                                <textarea id="setWords" class="w-full h-20 p-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-base" placeholder="Enter words separated by commas. Example: yo, mí, me..."></textarea>
                                <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Enter up to 30 words. Use commas to separate words.</p>
                            </div>
                            
                            <div class="mb-3">
                                <div class="flex items-center">
                                    <input type="checkbox" id="useRegexMatch" class="mr-2">
                                    <label for="useRegexMatch" class="text-sm">Use regex pattern matching</label>
                                </div>
                                <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Advanced: Use regular expressions for more complex pattern matching.</p>
                            </div>
                            
                            <div class="flex justify-end space-x-2 mt-4">
                                <button id="cancelEditBtn" class="bg-gray-300 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white px-4 py-2 rounded-full">Cancel</button>
                                <button id="saveSetBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-full">Save Set</button>
                            </div>
                        </div>
                        
                        <div id="previewContainer" class="border rounded-lg p-4 dark:bg-gray-800">
                            <h4 class="font-medium mb-2">Preview</h4>
                            <p id="previewDescription" class="text-sm text-gray-600 dark:text-gray-400 mb-3">Select a set to preview highlighting.</p>
                            <div id="previewContent" class="border p-3 rounded min-h-[120px] dark:bg-gray-700 dark:border-gray-600">
                                <p class="italic text-gray-500 dark:text-gray-400 text-center">No set selected</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mt-6 mb-2">
                    <h4 class="font-medium mb-2">Active Sets</h4>
                    <div id="activeSetsContainer" class="flex flex-wrap gap-2 mb-4 min-h-[40px] p-2 border rounded-lg dark:border-gray-700 bg-gray-50 dark:bg-gray-800">
                        <p class="italic text-gray-500 dark:text-gray-400 text-center w-full">No active sets. Select sets from the list to activate them.</p>
                    </div>
                </div>
                
                <!-- Stats container for custom sets -->
                <div id="customSetsStatsContainer" class="hidden stats-container">
                    <div class="stats-header">
                        <span>Custom Set</span>
                        <span>Count</span>
                    </div>
                    <ul id="customSetsStatsList" class="stats-list">
                        <!-- Will be populated by JavaScript -->
                    </ul>
                    <div class="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                        <div class="flex justify-between font-medium">
                            <span>Total matches:</span>
                            <span id="totalCustomSetMatches">0</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Homonym Patterns Tab -->
            <div id="homonymPatternsTab" class="tab-content p-4 rounded-lg border">
                <div class="tab-header">
                    <div class="flex items-center">
                        <h3 class="text-lg font-semibold">Homonym Sound Patterns</h3>
                        <div id="homonym-timer-container" class="hidden">
                            <div id="homonym-countdown-timer" class="countdown-timer">4</div>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <!-- Config changed warning appears inline with analyze button -->
                        <div id="homonymConfigChangedAlert" class="hidden flex items-center text-red-600 dark:text-red-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            <span class="text-sm">Configs changed. Rerun Analyze.</span>
                        </div>
                        <button id="analyzeHomonymBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-full">Analyze</button>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-5 gap-6 mb-4">
                    <!-- Detailed Results Panel - on left (3 columns) -->
                    <div class="md:col-span-3">
                        <div class="border rounded-lg p-3 dark:bg-gray-800" style="max-height: 500px; overflow-y: auto;">
                            <h4 class="font-medium mb-2 text-center">Found Matches</h4>
                            <div id="homonymResultsList" class="space-y-2">
                                <div class="text-center text-gray-500 italic">Click Analyze to see results</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Configuration for Homonym Patterns - on right (2 columns) -->
                    <div class="md:col-span-2">
                        <div class="grid grid-cols-1 gap-6">
                            <!-- Sound Pattern Location - MOVED TO TOP -->
                            <div class="option-group">
                                <h4 class="font-medium mb-3">Sound Pattern Location</h4>
                                <div class="flex justify-center mt-2 mb-2">
                                    <div class="flex w-full space-x-2">
                                        <div data-value="startStart" class="homonym-location-button flex-1 px-2 py-1 rounded-lg cursor-pointer bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-center active border-2 border-indigo-300 hover:border-indigo-300 transition-all" style="background-color: #5D5CDE; color: white;">
                                            <span>
                                                <span class="letter-highlight">ph</span>one <span class="letter-highlight">f</span>or
                                            </span>
                                        </div>
                                        <div data-value="endEnd" class="homonym-location-button flex-1 px-2 py-1 rounded-lg cursor-pointer bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-center border-2 border-transparent hover:border-indigo-300 transition-all">
                                            <span>
                                                ma<span class="letter-highlight">ze</span> ma<span class="letter-highlight">ce</span>
                                            </span>
                                        </div>
                                        <div data-value="endStart" class="homonym-location-button flex-1 px-2 py-1 rounded-lg cursor-pointer bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-center border-2 border-transparent hover:border-indigo-300 transition-all">
                                            <span>
                                                ma<span class="letter-highlight">ze</span> <span class="letter-highlight">ea</span>sy
                                            </span>
                                        </div>
                                    </div>
                                </div>
                                <div id="homonymLocationDescription" class="text-sm text-gray-600 dark:text-gray-400 italic mt-2 text-center">
                                    Start of the first word pattern matches the start of the next match pattern
                                </div>
                            </div>
                            
                            <!-- Words in Between - MOVED AFTER SOUND PATTERN LOCATION -->
                            <div class="option-group">
                                <h4 class="font-medium mb-3">Words in Between</h4>
                                <div class="slider-container">
                                    <input type="range" id="homonymWordsBetweenSlider" min="0" max="5" value="0" class="w-full accent-indigo-600 h-2 rounded-lg appearance-none cursor-pointer bg-gray-300 dark:bg-gray-700">
                                    <div class="flex justify-between mt-2 px-1 text-sm">
                                        <div>0</div>
                                        <div>1</div>
                                        <div>2</div>
                                        <div>3</div>
                                        <div>4</div>
                                        <div>5</div>
                                    </div>
                                    <div class="text-center font-medium mt-3">0</div>
                                </div>
                            </div>
                            
                            <!-- Homonym Groups Input - MOVED AFTER WORDS IN BETWEEN -->
                            <div class="option-group">
                                <div class="flex justify-between items-center mb-3">
                                    <h4 class="font-medium">Custom Homonym Pattern Groups</h4>
                                    <button id="editHomonymGroupsBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded-full text-sm">Edit</button>
                                </div>
                                
                                <!-- Reading mode view -->
                                <div id="homonymGroupsReadView" class="w-full bg-gray-50 dark:bg-gray-800 border rounded p-2 mb-2 max-h-[150px] overflow-y-auto">
                                    <div id="homonymGroupsContent" class="whitespace-pre-wrap font-mono text-sm"></div>
                                </div>
                                
                                <!-- Edit mode view (hidden by default) -->
                                <div id="homonymGroupsEditView" class="mb-2 hidden">
                                    <textarea id="homonymGroupsInput" class="w-full p-2 border rounded text-base" rows="6" placeholder="Enter homonym groups, one group per line.
Example:
ph,f
ture,che,chur
tion,sion,cian" readonly></textarea>
                                    <p class="text-sm text-gray-600 dark:text-gray-400 mt-2">
                                        Enter homonym groups, one group per line. Each group should be comma-separated patterns.
                                    </p>
                                    
                                    <!-- Edit mode buttons -->
                                    <div class="flex justify-end space-x-2 mt-2">
                                        <button id="cancelHomonymEditBtn" class="px-3 py-1 bg-gray-300 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-white rounded-full text-sm">Cancel</button>
                                        <button id="saveHomonymGroupsBtn" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full text-sm">Save</button>
                                    </div>
                                </div>
                                
                                <!-- Import/Export buttons -->
                                <div class="flex space-x-2 mb-3">
                                    <button id="exportHomonymGroupsBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded-full text-sm flex-1">Export</button>
                                    <button id="importHomonymGroupsBtn" class="bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded-full text-sm flex-1">Import</button>
                                </div>
                            </div>
                            
                            <!-- Predefined Sound Patterns - MOVED TO THE BOTTOM -->
                            <div class="option-group">
                                <div class="flex justify-between items-center mb-3">
                                    <h4 class="font-medium">Predefined Sound Patterns</h4>
                                    <label class="inline-flex items-center cursor-pointer">
                                        <span class="mr-2 text-sm">Enable</span>
                                        <div class="relative">
                                            <input type="checkbox" id="usePredefinedPatterns" class="sr-only peer" checked>
                                            <div class="w-9 h-5 bg-gray-200 peer-focus:outline-none rounded-full peer dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all dark:border-gray-600 peer-checked:bg-indigo-600"></div>
                                        </div>
                                    </label>
                                </div>
                                
                                <div id="predefinedPatternsContainer" class="mb-4 border rounded-lg p-2 max-h-40 overflow-y-auto bg-gray-50 dark:bg-gray-800">
                                    <div class="text-sm">
                                        <div class="grid grid-cols-1 sm:grid-cols-2 gap-1">
                                            <div class="p-1">"ai", "ay" (as in "Akai", "day")</div>
                                            <div class="p-1">"ee", "ea", "ie", "y" (as in "see", "sea", "Valerie", "happy")</div>
                                            <div class="p-1">"igh", "ie", "y" (as in "high", "tie", "fly")</div>
                                            <div class="p-1">"oat", "ow", "ould" (as in "boat", "show", "should")</div>
                                            <div class="p-1">"oo", "ue", "ew" (as in "loo", "blue", "few")</div>
                                            <div class="p-1">"oi", "oy" (as in "Koi", "boy")</div>
                                            <div class="p-1">"ur", "urn", "er" (as in "concur", "turn", "her")</div>
                                            <div class="p-1">"awe", "ove", "aw", "or" (as in "awe", "love", "saw")</div>
                                            <div class="p-1">"ph", "f" (as in "phone", "fish")</div>
                                            <div class="p-1">"ch", "tch" (as in "chip", "match")</div>
                                            <div class="p-1">"wh", "w" (as in "when", "wet")</div>
                                            <div class="p-1">"kn", "n" (as in "know", "not")</div>
                                            <div class="p-1">"wr", "r" (as in "write", "right")</div>
                                            <div class="p-1">"mb", "m" (as in "lamb", "ham")</div>
                                            <div class="p-1">"tion", "sion" (as in "action", "tension")</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Homophones Tab (renamed to Letter Patterns) -->
            <div id="homophonesTab" class="tab-content p-4 rounded-lg border">
                <div class="tab-header">
                    <div class="flex items-center">
                        <h3 class="text-lg font-semibold">Similar Letter Patterns</h3>
                        <div id="letter-timer-container" class="hidden">
                            <div id="letter-countdown-timer" class="countdown-timer">4</div>
                        </div>
                    </div>
                    <div class="flex items-center space-x-3">
                        <!-- Config changed warning appears inline with analyze button -->
                        <div id="configChangedAlert" class="hidden flex items-center text-red-600 dark:text-red-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            <span class="text-sm">Configs changed. Rerun Analyze.</span>
                        </div>
                        <button id="analyzeBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-full">Analyze</button>
                    </div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-5 gap-6 mb-4">
                    <!-- Detailed Results Panel - on left (3 columns) -->
                    <div class="md:col-span-3">
                        <div class="border rounded-lg p-3 dark:bg-gray-800" style="max-height: 500px; overflow-y: auto;">
                            <h4 class="font-medium mb-2 text-center">Found Matches</h4>
                            <div id="detailedResultsList" class="space-y-2">
                                <div class="text-center text-gray-500 italic">Click Analyze to see results</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Configuration for Letter Patterns - on right (2 columns) -->
                    <div class="md:col-span-2">
                        <div class="grid grid-cols-1 gap-6">
                            <!-- Letters Location in Words -->
                            <div class="option-group">
                                <h4 class="font-medium mb-3">Letters Location in Words</h4>
                                <div class="flex justify-center mt-2 mb-2">
                                    <div class="flex justify-between w-full">
                                        <div data-value="startSame" class="location-button px-4 py-2 rounded-lg cursor-pointer bg-gray-200 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-800 text-center active">
                                            <span><span class="letter-highlight">a</span>xe <span class="letter-highlight">a</span>ge</span>
                                        </div>
                                        <div data-value="endSame" class="location-button px-4 py-2 rounded-lg cursor-pointer bg-gray-200 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-800 text-center">
                                            <span>ax<span class="letter-highlight">e</span> ag<span class="letter-highlight">e</span></span>
                                        </div>
                                        <div data-value="endStartMatch" class="location-button px-4 py-2 rounded-lg cursor-pointer bg-gray-200 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-800 text-center">
                                            <span>ax<span class="letter-highlight">e</span> <span class="letter-highlight">e</span>gg</span>
                                        </div>
                                    </div>
                                </div>
                                <div id="locationDescription" class="text-sm text-gray-600 dark:text-gray-400 italic mt-2 text-center">
                                    Beginning of the first word matches the start of the next match
                                </div>
                            </div>
                            
                            <!-- Letters to Match -->
                            <div class="option-group">
                                <h4 class="font-medium mb-3">Letters/Symbols to Match</h4>
                                <div class="slider-container">
                                    <input type="range" id="lettersToMatchSlider" min="1" max="4" value="1" class="w-full accent-indigo-600 h-2 rounded-lg appearance-none cursor-pointer bg-gray-300 dark:bg-gray-700">
                                    <div class="flex justify-between mt-2 px-1 text-sm">
                                        <div>1</div>
                                        <div>2</div>
                                        <div>3</div>
                                        <div>4+</div>
                                    </div>
                                    <div class="text-center font-medium mt-3">1</div>
                                </div>
                                
                                <!-- Letter Match % - Moved under Letters/Symbols to Match -->
                                <h4 class="font-medium mb-2 mt-4">Letter Match %</h4>
                                <div id="letterPercentMatch">
                                    <div id="matchPercentOptions" class="flex flex-wrap gap-x-4 gap-y-2">
                                        <!-- All percentage match options use the same name for radio group -->
                                        <div id="oneLetterMatchOptions" class="flex">
                                            <input type="radio" id="match100Percent" name="matchPercent" value="100" checked>
                                            <label for="match100Percent" class="ml-1">100% match</label>
                                        </div>
                                        
                                        <!-- Options for 2 letters -->
                                        <div id="twoLetterMatchOptions" class="hidden flex">
                                            <input type="radio" id="match50Percent" name="matchPercent" value="50">
                                            <label for="match50Percent" class="ml-1">50% or more</label>
                                        </div>
                                        
                                        <!-- Options for 3 letters -->
                                        <div id="threeLetterMatchOptions" class="hidden flex">
                                            <input type="radio" id="match66Percent" name="matchPercent" value="66">
                                            <label for="match66Percent" class="ml-1">66% or more</label>
                                        </div>
                                        
                                        <!-- Options for 4+ letters -->
                                        <div id="fourLetterMatchOptions" class="hidden flex gap-x-2">
                                            <div>
                                                <input type="radio" id="match50PercentFour" name="matchPercent" value="50">
                                                <label for="match50PercentFour" class="ml-1">50% or more</label>
                                            </div>
                                            <div>
                                                <input type="radio" id="match75Percent" name="matchPercent" value="75">
                                                <label for="match75Percent" class="ml-1">75% or more</label>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Words in Between -->
                            <div class="option-group">
                                <h4 class="font-medium mb-3">Words in Between</h4>
                                <div class="slider-container">
                                    <input type="range" id="wordsBetweenSlider" min="0" max="5" value="0" class="w-full accent-indigo-600 h-2 rounded-lg appearance-none cursor-pointer bg-gray-300 dark:bg-gray-700">
                                    <div class="flex justify-between mt-2 px-1 text-sm">
                                        <div>0</div>
                                        <div>1</div>
                                        <div>2</div>
                                        <div>3</div>
                                        <div>4</div>
                                        <div>5</div>
                                    </div>
                                    <div class="text-center font-medium mt-3">0</div>
                                </div>
                            </div>
                            
                            <!-- Letter Order moved to its own section and on one line -->
                            <div class="option-group">
                                <h4 class="font-medium mb-2">Letter Order</h4>
                                <div class="flex gap-4">
                                    <div class="flex items-center">
                                        <input type="radio" id="exactOrderRadio" name="letterOrder" value="exact" checked class="mr-2">
                                        <label for="exactOrderRadio">Exact order</label>
                                    </div>
                                    
                                    <div class="flex items-center">
                                        <input type="radio" id="anyOrderRadio" name="letterOrder" value="any" class="mr-2">
                                        <label for="anyOrderRadio">Any order</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Rhythm Tab -->
            <div id="rhythmTab" class="tab-content p-4 rounded-lg border">
                <div class="tab-header flex items-center">
                    <!-- Left section with title -->
                    <div class="flex items-center">
                        <h3 class="text-lg font-semibold">Sentences Flow</h3>
                        <div id="timer-container" class="hidden ml-2">
                            <div id="countdown-timer" class="countdown-timer">4</div>
                        </div>
                    </div>
                    
                    <!-- Legend section - positioned with margin-left -->
                    <div class="flex items-center ml-8 space-x-4">
                        <div class="bar-size-toggle flex mr-4">
                            <button class="bar-size-btn text-xs px-2 py-1 rounded-l border border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700 active" data-size="small">S</button>
                            <button class="bar-size-btn text-xs px-2 py-1 border-t border-b border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700" data-size="medium">M</button>
                            <button class="bar-size-btn text-xs px-2 py-1 rounded-r border border-gray-300 dark:border-gray-600 bg-gray-100 dark:bg-gray-700" data-size="large">L</button>
                        </div>
                        <div class="rhythm-legend-item text-xs whitespace-nowrap">
                            <span class="rhythm-color-indicator legend-short h-3 w-3"></span>
                            <span>Short ≤5</span>
                        </div>
                        <div class="rhythm-legend-item text-xs whitespace-nowrap">
                            <span class="rhythm-color-indicator legend-medium h-3 w-3"></span>
                            <span>Medium 6-10</span>
                        </div>
                        <div class="rhythm-legend-item text-xs whitespace-nowrap">
                            <span class="rhythm-color-indicator legend-long h-3 w-3"></span>
                            <span>Long 11-20</span>
                        </div>
                        <div class="rhythm-legend-item text-xs whitespace-nowrap">
                            <span class="rhythm-color-indicator legend-extralong h-3 w-3"></span>
                            <span>Extra-Long 21+</span>
                        </div>
                    </div>
                    
                    <!-- Analyze button - pushed to the right with ml-auto -->
                    <button id="analyzeRhythmBtn" class="ml-auto bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-full">Analyze</button>
                </div>
                
                <!-- Chart container -->
                <div id="rhythm-container" class="border rounded-lg p-4 dark:bg-gray-800 mt-4">
                    <div id="cjk-indicator" class="hidden mb-3 text-sm bg-blue-100 text-blue-700 dark:bg-blue-900 dark:text-blue-300 px-3 py-2 rounded flex items-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span>CJK (Chinese/Japanese/Korean) text detected. Using Intl.Segmenter for word counting.</span>
                    </div>
                    <div id="sentence-chart">
                        <!-- Bars will be added here by JavaScript -->
                        <div class="text-center text-gray-500 dark:text-gray-400 italic py-16 w-full">Click Analyze to see sentence rhythm</div>
                    </div>
                </div>
                                <!-- Separate non-scrollable container for sentence distribution -->
                                <div id="distribution-container" class="border rounded-lg p-4 mt-4 dark:bg-gray-800 hidden">
                                    <!-- Distribution content will be added here by JavaScript -->
                                </div>
            </div>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Configure Quill with built-in RTL support
            // Import the existing formats we need
            const BackgroundClass = Quill.import('attributors/class/background');
            const BackgroundStyle = Quill.import('attributors/style/background');
            
            // Import direction formats for RTL support
            const DirectionAttribute = Quill.import('attributors/attribute/direction');
            const DirectionClass = Quill.import('attributors/class/direction');
            const DirectionStyle = Quill.import('attributors/style/direction');
            
            // Register the formats
            Quill.register(BackgroundClass, true);
            Quill.register(BackgroundStyle, true);
            Quill.register(DirectionAttribute, true);
            Quill.register(DirectionClass, true);
            Quill.register(DirectionStyle, true);
            
            // Enable more format types in Quill
            const Font = Quill.import('formats/font');
            const Size = Quill.import('formats/size');
            const Header = Quill.import('formats/header');
            const Align = Quill.import('formats/align');
            const Color = Quill.import('formats/color');
            const Bold = Quill.import('formats/bold');
            const Italic = Quill.import('formats/italic');
            
            // Register additional formats
            Quill.register(Font, true);
            Quill.register(Size, true);
            Quill.register(Header, true);
            Quill.register(Align, true);
            Quill.register(Color, true);
            
            // Initialize Quill editor with enhanced format support
            const quill = new Quill('#quill-editor', {
                modules: {
                    toolbar: {
                        container: [
                            ['undo', 'redo'],
                            [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                            [{ 'font': [] }],
                            [{ 'size': ['small', false, 'large', 'huge'] }],
                            ['bold', 'italic', 'underline', 'strike'],
                            [{ 'color': [] }, { 'background': [] }],
                            [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                            [{ 'align': [] }],
                            [{ 'direction': 'rtl' }],
                            ['clean']
                        ],
                        handlers: {
                            'undo': function() {
                                quill.history.undo();
                                updateTextStats(); // Update stats after undo
                            },
                            'redo': function() {
                                quill.history.redo();
                                updateTextStats(); // Update stats after redo
                            }
                        }
                    },
                    clipboard: {
                        // Enhanced clipboard module to preserve more formats
                        matchVisual: false
                    },
                    history: {
                        delay: 400,    // Increased delay for word-level undo/redo
                        maxStack: 500,  // Increased stack size to handle large documents
                        userOnly: true // Only user actions get added to history
                    }
                },
                placeholder: 'Start typing...',
                theme: 'snow',
                formats: [
                    'header', 'font', 'size', 'bold', 'italic', 'underline', 'strike',
                    'color', 'background', 'align', 'list', 'bullet', 'indent', 'direction'
                ]
            });
            
            // Try to load saved content from localStorage
            let initialContent = '';
            try {
                const savedContent = localStorage.getItem('wordPatternAnalyzerContent');
                if (savedContent) {
                    try {
                        // Try to parse as Delta object first
                        const parsedContent = JSON.parse(savedContent);
                        quill.setContents(parsedContent);
                        console.log('Loaded saved content from localStorage');
                    } catch (e) {
                        // If parsing fails, treat as plain text
                        quill.setText(savedContent);
                        console.log('Loaded saved text from localStorage');
                    }
                } else {
                    // No saved content - use initial content from the div
                    initialContent = document.getElementById('quill-editor').textContent;
                    quill.setText(initialContent);
                }
            } catch (e) {
                // If localStorage fails, fall back to initial content
                console.error('Error loading from localStorage:', e);
                initialContent = document.getElementById('quill-editor').textContent;
                quill.setText(initialContent);
            }
            
            // Initialize Word Pattern Controls right at the start
            initWordPatternControls();
            
            // Setup metrics panel toggle with localStorage persistence
            const metricsToggle = document.getElementById('metricsToggle');
            const metricsContent = document.getElementById('metricsContent');
            const chevron = metricsToggle.querySelector('.chevron');
            
            // Check localStorage for saved metrics panel state
            try {
                const metricsExpanded = localStorage.getItem('wordPatternAnalyzerMetricsExpanded');
                if (metricsExpanded === 'false') {
                    // If saved as collapsed, collapse the panel
                    metricsContent.classList.remove('expanded');
                    chevron.classList.remove('rotated');
                } else {
                    // Default is expanded (or saved as expanded)
                    metricsContent.classList.add('expanded');
                    chevron.classList.add('rotated');
                }
            } catch (error) {
                console.error('Error reading metrics state from localStorage:', error);
                // Default to expanded on error
                metricsContent.classList.add('expanded');
                chevron.classList.add('rotated');
            }
            
            metricsToggle.addEventListener('click', function() {
                // Toggle the expanded state
                const isExpanded = metricsContent.classList.toggle('expanded');
                chevron.classList.toggle('rotated');
                
                // Save the state to localStorage
                try {
                    localStorage.setItem('wordPatternAnalyzerMetricsExpanded', isExpanded);
                } catch (error) {
                    console.error('Error saving metrics state to localStorage:', error);
                }
            });
            
            // Text statistics counter functionality
            const wordCountEl = document.getElementById('wordCount');
            const charCountEl = document.getElementById('charCount');
            const charWithSpacesCountEl = document.getElementById('charWithSpacesCount');
            const readingTimeEl = document.getElementById('readingTime');
            
            // Add a variable to track the text that was last analyzed in the Density tab
            let lastDensityText = '';
            
            // Variables to store editor content for preserving formatting
            let editorContents = null;
            let userFormattedContents = null;
            let lastActiveTab = 'densityTab'; // Track which tab was last active
            
            // Variables to store the selection state
            let lastSelectionRange = null;
            let lastActiveTabSelection = {};
            
            // Save the editor's contents (including formatting), selection state, and scroll position
            function saveEditorContents() {
                // Store full contents with all formatting
                editorContents = quill.getContents();
                
                // Store a version with just user formatting (without analysis highlights)
                userFormattedContents = removeAnalysisHighlights(quill.getContents());
                
                // Save current selection
                lastSelectionRange = quill.getSelection();
                
                // Store the selection in tab-specific storage
                if (lastActiveTab && lastSelectionRange) {
                    lastActiveTabSelection[lastActiveTab] = {...lastSelectionRange};
                }
                
                // Save current scroll position
                const editorContainer = document.querySelector('.ql-editor');
                if (editorContainer) {
                    lastScrollPosition = editorContainer.scrollTop;
                }
            }
            
            // Remove analysis highlights but keep user formatting
            function removeAnalysisHighlights(content) {
                // Clone the content
                const cleanContent = JSON.parse(JSON.stringify(content || quill.getContents()));
                
                // Remove all background color and associated text color formatting
                if (cleanContent && cleanContent.ops) {
                    cleanContent.ops.forEach(op => {
                        if (op.attributes) {
                            // Remove any background formatting
                            if (op.attributes.background) {
                                delete op.attributes.background;
                            }
                            
                            // Remove any text color that's likely from highlights
                            if (op.attributes.color && 
                                (op.attributes.color === 'white' || op.attributes.color === 'black')) {
                                delete op.attributes.color;
                            }
                            
                            // Remove empty attributes object
                            if (Object.keys(op.attributes).length === 0) {
                                delete op.attributes;
                            }
                        }
                    });
                }
                
                return cleanContent;
            }
            
            // Restore the editor's contents and selection state
            function restoreEditorContents(cleanVersion = false) {
                // If cleanVersion is true, restore without analysis highlights
                // Otherwise restore the full contents
                if (cleanVersion && userFormattedContents) {
                    quill.setContents(userFormattedContents);
                } else if (editorContents) {
                    quill.setContents(editorContents);
                }
                
                // Restore the selection for the current tab
                if (lastActiveTab && lastActiveTabSelection[lastActiveTab]) {
                    quill.setSelection(
                        lastActiveTabSelection[lastActiveTab].index,
                        lastActiveTabSelection[lastActiveTab].length || 0
                    );
                } else if (lastSelectionRange) {
                    // Fallback to last saved selection if no tab-specific selection found
                    quill.setSelection(lastSelectionRange.index, lastSelectionRange.length || 0);
                }
                
                // Restore the scroll position if available
                if (lastScrollPosition !== undefined) {
                    const editorContainer = document.querySelector('.ql-editor');
                    if (editorContainer) {
                        editorContainer.scrollTop = lastScrollPosition;
                    }
                }
            }
            
            // Completely clear all highlights before starting a new analysis
            function clearAllHighlights() {
                if (userFormattedContents) {
                    // Apply the clean version without highlights
                    quill.setContents(userFormattedContents);
                    
                    // Re-save the clean version as the current editor contents
                    editorContents = JSON.parse(JSON.stringify(userFormattedContents));
                    
                    // Return true if we successfully cleared
                    return true;
                }
                return false;
            }
            
            // Get the text from Quill editor
            function getEditableText() {
                return quill.getText() || '';
            }
            
            // Set up Quill editor change event
            quill.on('text-change', function(delta, oldDelta, source) {
                // Update text statistics
                updateTextStats();
                
                // Save the current editor state for format preservation
                saveEditorContents();
                
                // Update the UI button states
                updateUndoRedoButtons();
                
                // Save content to localStorage
                try {
                    // Save the Delta object (preserves formatting)
                    localStorage.setItem('wordPatternAnalyzerContent', JSON.stringify(quill.getContents()));
                    console.log('Saved content to localStorage');
                } catch (e) {
                    console.error('Error saving to localStorage:', e);
                }
            });
            
            // Improved paste handler that preserves undo/redo functionality
            quill.root.addEventListener('paste', function(e) {
                // We're going to let Quill handle the paste entirely by itself first
                // This ensures proper history tracking
                
                // After the paste operation is complete and in the history stack
                setTimeout(() => {
                    // Get the current Delta representation
                    const currentContents = quill.getContents();
                    
                    // Only proceed if we have content and need to clean formatting
                    if (currentContents && currentContents.ops) {
                        // Create a cleaning Delta that only targets color/background attributes
                        const cleaningDelta = new Delta();
                        
                        let index = 0;
                        currentContents.ops.forEach(op => {
                            // Only process operations with text and attributes
                            if (typeof op.insert === 'string' && op.attributes) {
                                const hasFormatting = op.attributes.background || op.attributes.color;
                                
                                // Only create a formatting Delta if there's color/background to remove
                                if (hasFormatting) {
                                    // Create an attributes object with null values to remove these formats
                                    const removeAttrs = {};
                                    if (op.attributes.background) removeAttrs.background = null;
                                    if (op.attributes.color) removeAttrs.color = null;
                                    
                                    // Add a retain + attributes operation to the Delta
                                    cleaningDelta.retain(op.insert.length, removeAttrs);
                                } else {
                                    // Just retain without changing attributes
                                    cleaningDelta.retain(op.insert.length);
                                }
                                
                                index += op.insert.length;
                            } else if (op.insert) {
                                // For non-string inserts (like embeds), just retain
                                cleaningDelta.retain(1);
                                index += 1;
                            }
                        });
                        
                        // Only apply the Delta if we made changes
                        if (cleaningDelta.ops.length > 0) {
                            // Apply the cleaning delta - this preserves the history stack
                            // Use 'silent' as the source to avoid adding another history entry
                            quill.updateContents(cleaningDelta, 'silent');
                        }
                    }
                    
                    // Save the editor contents for our own tracking
                    saveEditorContents();
                }, 100); // Increased timeout to give Quill time to process the paste
            });
            
            // Variables for undo/redo functionality
            let currentHistoryIndex = 0;
            let textHistory = [];
            
            // Add to history
            function addToHistory(text, force = false) {
                // If the new text is the same as the last history entry, don't add it
                if (textHistory.length > 0 && textHistory[currentHistoryIndex] === text && !force) {
                    return;
                }
                
                // If we're not at the end of the history, truncate it
                if (currentHistoryIndex < textHistory.length - 1) {
                    textHistory = textHistory.slice(0, currentHistoryIndex + 1);
                }
                
                // Add the new text to history
                textHistory.push(text);
                
                // If history exceeds max size, remove the oldest entry
                const MAX_HISTORY_SIZE = 100;
                if (textHistory.length > MAX_HISTORY_SIZE) {
                    textHistory.shift();
                } else {
                    currentHistoryIndex = textHistory.length - 1;
                }
                
                // Update UI button states
                updateUndoRedoButtons();
            }
            
            // Undo action
            function undo() {
                if (currentHistoryIndex > 0) {
                    currentHistoryIndex--;
                    // Use Quill to set the text content
                    quill.setText(textHistory[currentHistoryIndex]);
                    updateUndoRedoButtons();
                }
            }
            
            // Redo action
            function redo() {
                if (currentHistoryIndex < textHistory.length - 1) {
                    currentHistoryIndex++;
                    // Use Quill to set the text content
                    quill.setText(textHistory[currentHistoryIndex]);
                    updateUndoRedoButtons();
                }
            }
            
            // Update the undo/redo button states - modified to use Quill's built-in history
            function updateUndoRedoButtons() {
                // Quill handles its own toolbar button states
                // This function is kept as a no-op for backward compatibility
            }
            
            // Implement throttling for metrics updates
            let pendingMetricsUpdate = false;
            let lastMetricsText = "";
            
            // Character limit for text input (99.99k)
            const MAX_CHAR_LIMIT = 99990;
            
            // Add character limit check to the Quill editor
            quill.on('text-change', function(delta, oldDelta, source) {
                // Check if the text length exceeds the MAX_CHAR_LIMIT
                const currentText = quill.getText();
                if (currentText.length > MAX_CHAR_LIMIT) {
                    // Revert to previous content
                    quill.setContents(oldDelta);
                    
                    // Show error notification
                    const notification = document.createElement('div');
                    notification.className = 'fixed top-4 right-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded shadow-lg z-50';
                    notification.innerHTML = `
                        <div class="flex">
                            <div class="py-1"><svg class="fill-current h-6 w-6 text-red-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z"/></svg></div>
                            <div>
                                <p class="font-bold">Character limit exceeded</p>
                                <p class="text-sm">Text cannot exceed ${MAX_CHAR_LIMIT.toLocaleString()} characters for optimal performance.</p>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(notification);
                    
                    // Remove notification after 4 seconds
                    setTimeout(() => {
                        notification.remove();
                    }, 4000);
                    
                    return;
                }
            });
            
            // Set up theme toggles
            document.getElementById('lightThemeBtn').addEventListener('click', function() {
                document.documentElement.classList.remove('dark');
                localStorage.setItem('theme', 'light');
                updateThemeButtonStyles('light');
            });
            
            document.getElementById('darkThemeBtn').addEventListener('click', function() {
                document.documentElement.classList.add('dark');
                localStorage.setItem('theme', 'dark');
                updateThemeButtonStyles('dark');
            });
            
            document.getElementById('systemThemeBtn').addEventListener('click', function() {
                localStorage.removeItem('theme');
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                updateThemeButtonStyles('system');
            });
            
            // Set initial theme based on saved preference or system
            function initializeTheme() {
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme === 'dark') {
                    document.documentElement.classList.add('dark');
                    updateThemeButtonStyles('dark');
                } else if (savedTheme === 'light') {
                    document.documentElement.classList.remove('dark');
                    updateThemeButtonStyles('light');
                } else {
                    // System default
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        document.documentElement.classList.add('dark');
                    }
                    updateThemeButtonStyles('system');
                }
            }
            
            // Update active state of theme buttons
            function updateThemeButtonStyles(activeTheme) {
                // Remove active class from all buttons
                document.getElementById('lightThemeBtn').classList.remove('bg-gray-200');
                document.getElementById('darkThemeBtn').classList.remove('bg-gray-200');
                document.getElementById('systemThemeBtn').classList.remove('bg-gray-200');
                
                // Reset all icon colors first
                document.getElementById('darkThemeBtn').querySelector('svg').style.color = '';
                document.getElementById('systemThemeBtn').querySelector('svg').style.color = '';
                
                // Add active class to the selected button
                if (activeTheme === 'light') {
                    document.getElementById('lightThemeBtn').classList.add('bg-gray-200');
                    // Moon icon should be dark in light theme
                    document.getElementById('darkThemeBtn').querySelector('svg').style.color = 'black';
                } else if (activeTheme === 'dark') {
                    document.getElementById('darkThemeBtn').classList.add('bg-gray-200');
                    // Moon icon should be dark when selected
                    document.getElementById('darkThemeBtn').querySelector('svg').style.color = 'black';
                } else if (activeTheme === 'system') {
                    document.getElementById('systemThemeBtn').classList.add('bg-gray-200');
                    // System icon should be dark when selected
                    document.getElementById('systemThemeBtn').querySelector('svg').style.color = 'black';
                }
            }
            
            // Initialize theme on load
            initializeTheme();
            
            // Initialize bar size toggle for rhythm tab
            function initBarSizeToggle() {
                document.querySelectorAll('.bar-size-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        // Remove active class from all buttons
                        document.querySelectorAll('.bar-size-btn').forEach(b => b.classList.remove('active'));
                        // Add active class to clicked button
                        this.classList.add('active');
                        
                        // Get the selected size
                        const size = this.dataset.size;
                        
                        // Update CSS variable for bar width
                        if (size === 'small') {
                            document.documentElement.style.setProperty('--rhythm-bar-width', '11px');
                        } else if (size === 'medium') {
                            document.documentElement.style.setProperty('--rhythm-bar-width', '18px');
                        } else if (size === 'large') {
                            document.documentElement.style.setProperty('--rhythm-bar-width', '25px');
                        }
                        
                        // Rerun the chart generation if it exists
                        if (sentences && sentences.length > 0) {
                            analyzeRhythm();
                        }
                    });
                });
            }
            
            // Initialize bar size toggle
            initBarSizeToggle();
            
            // Throttled update text statistics to improve performance
            function updateTextStats(forceUpdate = false) {
                const text = getEditableText();
                const isLargeText = text.length > 50000;
                
                // Show loading indicators for large texts or forced updates
                if (isLargeText || forceUpdate) {
                    document.querySelectorAll('.metrics-loading').forEach(el => {
                        el.classList.remove('hidden');
                    });
                }
                
                // Skip if text is identical to last update and not forced
                if (text === lastMetricsText && !forceUpdate) return;
                
                // If an update is already pending, don't schedule another one unless forced
                if (pendingMetricsUpdate && !forceUpdate) return;
                
                // Mark that we have a pending update
                pendingMetricsUpdate = true;
                
                // For extremely large texts, use a more aggressive throttling approach
                // with a brief timeout to allow the UI to remain responsive
                if (isLargeText) {
                    setTimeout(() => {
                        processMetricsUpdate(text, forceUpdate);
                    }, 10);
                } else {
                    // Use requestAnimationFrame for better performance with normal-sized texts
                    requestAnimationFrame(() => {
                        processMetricsUpdate(text, forceUpdate);
                    });
                }
            }
            
            // Separate function to handle the actual metrics calculation and update
            function processMetricsUpdate(text, forceUpdate) {
                const startTime = performance.now();
                
                // Store this text for comparison next time
                lastMetricsText = text;
                
                // Count words (split by whitespace and filter out empty strings)
                // For large texts, this is more efficient than using regex
                const words = text.split(/\s+/);
                const wordCount = words.filter(word => word.length > 0).length;
                
                // Count characters (without spaces)
                const charCount = text.replace(/\s+/g, '').length;
                
                // Count characters with spaces
                const charWithSpacesCount = text.length;
                
                // Count paragraphs - any line with content counts as a paragraph
                const paragraphCount = text.split('\n')
                    .filter(line => line.trim().length > 0)
                    .length;
                
                // Count sentences - only on texts smaller than 10K chars for performance
                // or ones that have changed substantially
                let sentenceCount;
                if (text.length > 10000) {
                    // For large texts, estimate based on average sentence length
                    sentenceCount = Math.round(wordCount / 15); // Assume ~15 words per sentence
                } else {
                    sentenceCount = countSentences(text);
                }
                
                // Calculate reading time (average reading speed is ~200-250 words per minute)
                const wordsPerMinute = 225;
                const totalSeconds = Math.max(5, Math.round((wordCount / wordsPerMinute) * 60));
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                
                // Update UI elements
                wordCountEl.textContent = wordCount;
                charCountEl.textContent = charCount;
                charWithSpacesCountEl.textContent = charWithSpacesCount;
                document.getElementById('paragraphCount').textContent = paragraphCount;
                document.getElementById('sentenceCount').textContent = sentenceCount;
                readingTimeEl.textContent = minutes > 0 
                    ? `${minutes} min ${seconds} sec` 
                    : `${seconds} sec`;
                
                // Hide loading indicators
                document.querySelectorAll('.metrics-loading').forEach(el => {
                    el.classList.add('hidden');
                });
                    
                // Reset the pending flag
                pendingMetricsUpdate = false;
                
                // For debugging timing issues
                // console.log(`Metrics update took ${performance.now() - startTime}ms`);
            }
            
            // Count sentences in text with improved handling of closing symbols like }]")
            function countSentences(text) {
                if (!text.trim()) return 0;
                
                // Count sentences by finding patterns ending with .!? followed by optional closing symbols
                // The regex looks for sentence-ending punctuation + optional closing symbols + whitespace
                const cleanText = text
                    .replace(/(\b(?:Mr|Mrs|Ms|Dr|Jr|Sr|Prof|Gen|Rep|Sen|St|Ave|Inc|Ltd|Co|Corp|vs)\.\s)/gi, '$1<ABBREVIATION>')
                    .replace(/(\d+\.\d+)/g, '$1<DECIMAL>')
                    .replace(/(\w\.\w\.)/g, '$1<ABBREVIATION>');
                
                // Match sentence ending patterns with consideration for closing symbols
                const sentenceEndings = cleanText.match(/[.!?]+[\}\]\)"]*(?=\s|$)/g) || [];
                
                // Count paragraph breaks as potential sentence breaks too
                const paragraphBreaks = (text.match(/\n\s*\n/g) || []).length;
                
                return sentenceEndings.length + paragraphBreaks;
            }
            
            // Note: Undo/Redo buttons are now in Quill toolbar with handlers
            // No need for separate event listeners here
            
            // Setup export buttons
            document.getElementById('exportTxtBtn').addEventListener('click', exportAsTxt);
            document.getElementById('exportRtfBtn').addEventListener('click', exportAsRtf);
            
            // Setup copy button functionality
            document.getElementById('copyTextBtn').addEventListener('click', function() {
                // Get the Quill content without background and font colors
                const cleanContent = stripColorFormatting(quill.getContents());
                
                // Create a temporary div and hidden textarea for proper copying
                const tempDiv = document.createElement('div');
                document.body.appendChild(tempDiv);
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px';
                
                // Create a temporary Quill instance in the hidden div
                const tempQuill = new Quill(tempDiv, {
                    modules: {
                        toolbar: false
                    },
                    theme: 'bubble' // Use bubble theme to minimize extra markup
                });
                
                // Set the clean content to the temporary Quill instance
                tempQuill.setContents(cleanContent);
                
                // Get the plain text with basic formatting as fallback
                const plainText = tempQuill.getText();
                
                // Create a temporary textarea for better copying with rich text
                const textarea = document.createElement('textarea');
                textarea.value = plainText;
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                
                // Select the text and copy
                textarea.select();
                
                try {
                    // Try to copy rich text format first
                    const range = document.createRange();
                    range.selectNodeContents(tempDiv.querySelector('.ql-editor'));
                    
                    const selection = window.getSelection();
                    selection.removeAllRanges();
                    selection.addRange(range);
                    
                    const successful = document.execCommand('copy');
                    
                    if (!successful) {
                        // Fall back to plain text if rich text copy fails
                        document.execCommand('copy');
                    }
                    
                    // Show success message
                    const successMessage = document.createElement('div');
                    successMessage.className = 'fixed bottom-4 right-4 bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded shadow-lg z-50';
                    successMessage.innerHTML = `
                        <div class="flex">
                            <div class="py-1"><svg class="fill-current h-6 w-6 text-green-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM6.7 9.29L9 11.6l4.3-4.3 1.4 1.42L9 14.4l-3.7-3.7 1.4-1.42z"/></svg></div>
                            <div>
                                <p class="font-bold">Copied!</p>
                                <p class="text-sm">Text copied to clipboard with formatting preserved (except colors).</p>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(successMessage);
                    
                    // Remove success message after 3 seconds
                    setTimeout(() => {
                        successMessage.remove();
                    }, 3000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    alert('Failed to copy text. Please try again.');
                } finally {
                    // Clean up the temporary elements
                    document.body.removeChild(textarea);
                    document.body.removeChild(tempDiv);
                    
                    // Clear selection
                    window.getSelection().removeAllRanges();
                }
            });
            
            // Helper function to strip background and color formatting but preserve other formatting
            function stripColorFormatting(delta) {
                if (!delta || !delta.ops) return delta;
                
                const cleanDelta = { ops: [] };
                
                delta.ops.forEach(op => {
                    const newOp = { ...op };
                    
                    if (newOp.attributes) {
                        const newAttributes = { ...newOp.attributes };
                        
                        // Remove background and color attributes
                        delete newAttributes.background;
                        delete newAttributes.color;
                        
                        // Only keep attributes object if there are still attributes left
                        if (Object.keys(newAttributes).length > 0) {
                            newOp.attributes = newAttributes;
                        } else {
                            delete newOp.attributes;
                        }
                    }
                    
                    cleanDelta.ops.push(newOp);
                });
                
                return cleanDelta;
            }
            
            // Export functions
            function exportAsTxt() {
                // Get the plain text content from the editor
                const text = quill.getText();
                if (!text.trim()) {
                    alert('Please enter some text to export.');
                    return;
                }
                
                // Create a text/plain blob
                const blob = new Blob([text], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                
                // Create modal with instructions for saving
                showExportModal('TXT', url, 'text.txt', 'Text File');
            }
            
            function exportAsRtf() {
                // Get the editor content with formatting
                const content = quill.getContents();
                if (!content.ops || !content.ops.length) {
                    alert('Please enter some text to export.');
                    return;
                }
                
                // Create RTF content with formatting
                const rtfContent = convertToRtf(content);
                
                // Create blob and show export modal
                const blob = new Blob([rtfContent], { type: 'application/rtf' });
                const url = URL.createObjectURL(blob);
                
                // Show modal with instructions
                showExportModal('RTF', url, 'document.rtf', 'Rich Text Format');
            }
            
            // DOCX export function using docx.js library
            // DOCX export removed since RTF is sufficient for Word compatibility
            
            // Convert Quill delta to docx paragraphs
            function convertQuillToParagraphs(quillContent) {
                const paragraphs = [];
                let currentParagraph = { text: '', runs: [] };
                let currentRun = { text: '', bold: false, italic: false, underline: false };
                
                // Process each op in the Quill delta
                quillContent.ops.forEach(op => {
                    if (typeof op.insert === 'string') {
                        if (op.insert === '\n') {
                            // End of paragraph
                            if (currentRun.text) {
                                currentParagraph.runs.push(currentRun);
                                currentRun = { text: '', bold: false, italic: false, underline: false };
                            }
                            
                            // Add paragraph to the list if it has content
                            if (currentParagraph.runs.length > 0) {
                                paragraphs.push(createDocxParagraph(currentParagraph.runs, op.attributes));
                                currentParagraph = { text: '', runs: [] };
                            } else {
                                // Empty paragraph
                                paragraphs.push(new docx.Paragraph({}));
                            }
                        } else {
                            // Normal text
                            const newTextRun = { 
                                text: op.insert, 
                                bold: op.attributes?.bold || false,
                                italic: op.attributes?.italic || false,
                                underline: op.attributes?.underline || false,
                                color: op.attributes?.color || undefined,
                                highlight: op.attributes?.background || undefined,
                                strike: op.attributes?.strike || false
                            };
                            
                            // Check if formatting changed - if so, create a new run
                            if (formatChanged(currentRun, newTextRun) && currentRun.text) {
                                currentParagraph.runs.push(currentRun);
                                currentRun = newTextRun;
                            } else {
                                // Append to current run if formatting is the same
                                if (formatChanged(currentRun, newTextRun)) {
                                    // If format changed but currentRun is empty, just replace it
                                    currentRun = newTextRun;
                                } else {
                                    // Append text to current run
                                    currentRun.text += op.insert;
                                }
                            }
                        }
                    }
                });
                
                // Add any remaining content as a paragraph
                if (currentRun.text) {
                    currentParagraph.runs.push(currentRun);
                }
                
                if (currentParagraph.runs.length > 0) {
                    paragraphs.push(createDocxParagraph(currentParagraph.runs));
                }
                
                return paragraphs;
            }
            
            // Check if text formatting changed
            function formatChanged(run1, run2) {
                return run1.bold !== run2.bold ||
                       run1.italic !== run2.italic ||
                       run1.underline !== run2.underline ||
                       run1.color !== run2.color ||
                       run1.highlight !== run2.highlight ||
                       run1.strike !== run2.strike;
            }
            
            // Create a docx paragraph with properly formatted runs
            function createDocxParagraph(textRuns, attributes = {}) {
                const children = textRuns.map(run => {
                    // Convert the run to a proper docx TextRun
                    const textRunOptions = {
                        text: run.text,
                        bold: run.bold,
                        italics: run.italic,
                        strike: run.strike
                    };
                    
                    // Add underline if needed
                    if (run.underline) {
                        textRunOptions.underline = {
                            type: docx.UnderlineType.SINGLE
                        };
                    }
                    
                    // Add text color if specified
                    if (run.color) {
                        textRunOptions.color = run.color;
                    }
                    
                    // Add highlight if specified
                    if (run.highlight) {
                        textRunOptions.highlight = docx.HighlightColor.YELLOW;
                    }
                    
                    return new docx.TextRun(textRunOptions);
                });
                
                // Set up paragraph properties
                const paragraphOptions = {
                    children
                };
                
                // Apply paragraph styles based on attributes
                if (attributes) {
                    // Check if this is a heading
                    if (attributes.header) {
                        // Map Quill heading levels to docx heading styles
                        const headingLevelMap = {
                            1: docx.HeadingLevel.HEADING_1,
                            2: docx.HeadingLevel.HEADING_2,
                            3: docx.HeadingLevel.HEADING_3,
                            4: docx.HeadingLevel.HEADING_4,
                            5: docx.HeadingLevel.HEADING_5,
                            6: docx.HeadingLevel.HEADING_6
                        };
                        paragraphOptions.heading = headingLevelMap[attributes.header];
                    }
                    
                    // Apply alignment
                    if (attributes.align) {
                        const alignmentMap = {
                            'center': docx.AlignmentType.CENTER,
                            'right': docx.AlignmentType.RIGHT,
                            'justify': docx.AlignmentType.JUSTIFIED,
                            'left': docx.AlignmentType.LEFT
                        };
                        
                        if (alignmentMap[attributes.align]) {
                            paragraphOptions.alignment = alignmentMap[attributes.align];
                        }
                    }
                }
                
                return new docx.Paragraph(paragraphOptions);
            }
            
            function showExportModal(format, fileUrl, fileName, formatName) {
                // Create modal dialog
                const modal = document.createElement('div');
                modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg max-w-md w-full">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-lg font-semibold">Export as ${format}</h3>
                            <button class="close-modal-btn text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                </svg>
                            </button>
                        </div>
                        <p class="mb-4">Your ${formatName} file is ready. Due to browser security restrictions, please:</p>
                        <ol class="list-decimal pl-5 mb-4 space-y-2">
                            <li>Right-click the link below</li>
                            <li>Select "Save link as" or similar option</li>
                            <li>Save the file to your computer</li>
                        </ol>
                        <div class="mb-4 text-center">
                            <a href="${fileUrl}" download="${fileName}" target="_blank" class="inline-flex items-center px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-md">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                </svg>
                                Download ${format} File
                            </a>
                        </div>
                        <div class="text-center">
                            <button class="close-modal-btn px-4 py-2 bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 rounded-md">Close</button>
                        </div>
                    </div>
                `;
                
                // Add to document
                document.body.appendChild(modal);
                
                // Add event listener for close button
                modal.querySelectorAll('.close-modal-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        modal.remove();
                        URL.revokeObjectURL(fileUrl);
                    });
                });
            }
            
            // Helper function to convert Quill content to RTF with improved heading styles and line breaks
            function convertToRtf(quillContent) {
                // Enhanced RTF header with expanded font table
                let rtf = '{\\rtf1\\ansi\\ansicpg1252\\cocoartf2580\\cocoasubrtf220\n' +
                          '{\\fonttbl' + 
                          '{\\f0\\fswiss\\fcharset0 Arial;}' +
                          '{\\f1\\fswiss\\fcharset0 Arial-Bold;}' +
                          '{\\f2\\froman\\fcharset0 Times-Roman;}' +
                          '{\\f3\\froman\\fcharset0 Times-Bold;}' +
                          '{\\f4\\fmodern\\fcharset0 Courier;}' +
                          '{\\f5\\fmodern\\fcharset0 Courier-Bold;}' +
                          '{\\f6\\fnil\\fcharset0 Georgia;}' +
                          '{\\f7\\fswiss\\fcharset0 Helvetica;}' +
                          '{\\f8\\fswiss\\fcharset0 Helvetica-Bold;}' +
                          '{\\f9\\fnil\\fcharset0 Tahoma;}' +
                          '{\\f10\\fnil\\fcharset0 Verdana;}' +
                          '}\n' +
                          '{\\colortbl;\\red255\\green255\\blue255;\\red0\\green0\\blue0;' +
                          '\\red255\\green0\\blue0;\\red0\\green0\\blue255;\\red0\\green128\\blue0;}\n' +
                          '\\vieww12000\\viewh15840\\viewkind0\n' +
                          // Create style sheet with proper heading styles
                          '{\\stylesheet' +
                          '{\\s0\\snext0\\ql\\nowidctlpar\\faauto\\li0\\ri0\\lin0\\rin0\\fi0\\ltrpar\\f0\\fs24 Normal;}' +
                          '{\\s1\\sbasedon0\\snext0\\outlinelevel0\\b\\f1\\fs40\\keepn Heading 1;}' +
                          '{\\s2\\sbasedon0\\snext0\\outlinelevel1\\b\\f1\\fs36\\keepn Heading 2;}' +
                          '{\\s3\\sbasedon0\\snext0\\outlinelevel2\\b\\f1\\fs32\\keepn Heading 3;}' +
                          '{\\s4\\sbasedon0\\snext0\\outlinelevel3\\b\\f1\\fs28\\keepn Heading 4;}' +
                          '{\\s5\\sbasedon0\\snext0\\outlinelevel4\\b\\i\\f1\\fs24\\keepn Heading 5;}' +
                          '{\\s6\\sbasedon0\\snext0\\outlinelevel5\\b\\i\\f1\\fs22\\keepn Heading 6;}' +
                          '}\n' +
                          '\\pard\\tx720\\tx1440\\tx2160\\tx2880\\tx3600\\tx4320\\pardirnatural\\partightenfactor0\n\n';
                
                // Track paragraph state
                let inParagraph = false;
                let currentHeader = null;
                let buffer = '';
                let paragraphFormatting = ''; // Store paragraph-level formatting
                
                // Map Quill font names to RTF font indices
                const fontMap = {
                    'arial': 0,
                    'times-new-roman': 2,
                    'courier-new': 4,
                    'courier': 4,
                    'georgia': 6,
                    'helvetica': 7,
                    'tahoma': 9,
                    'verdana': 10,
                    // Default to Arial if no match
                    'default': 0
                };
                
                // Process paragraph by paragraph for better structure
                let currentParagraph = [];
                let paragraphAttributes = null;
                
                // Group ops by paragraph
                for (let i = 0; i < quillContent.ops.length; i++) {
                    const op = quillContent.ops[i];
                    
                    if (typeof op.insert === 'string' && op.insert === '\n') {
                        // End of paragraph - process and start new one
                        
                        // If the newline has attributes, they apply to the paragraph
                        if (op.attributes) {
                            paragraphAttributes = op.attributes;
                        }
                        
                        // Process the current paragraph
                        if (currentParagraph.length > 0 || paragraphAttributes) {
                            buffer += processParagraph(currentParagraph, paragraphAttributes);
                            // Reset for next paragraph
                            currentParagraph = [];
                            paragraphAttributes = null;
                        } else {
                            // Empty paragraph
                            buffer += '\\pard\\par\n';
                        }
                    } else {
                        // Add to current paragraph
                        currentParagraph.push(op);
                    }
                }
                
                // Process any remaining content as a paragraph
                if (currentParagraph.length > 0) {
                    buffer += processParagraph(currentParagraph, paragraphAttributes);
                }
                
                // Function to process a paragraph's worth of ops
                function processParagraph(ops, attributes) {
                    if (!ops || ops.length === 0) return '';
                    
                    let paragraphBuffer = '';
                    let headerLevel = null;
                    
                    // Start paragraph with appropriate formatting
                    paragraphBuffer += '\\pard';
                    
                    // Apply heading style if present
                    if (attributes && attributes.header) {
                        headerLevel = attributes.header;
                        paragraphBuffer += `\\s${headerLevel}`;
                    }
                    
                    // Apply alignment if present
                    if (attributes && attributes.align) {
                        const alignMap = {
                            'center': '\\qc',
                            'right': '\\qr',
                            'justify': '\\qj',
                            'left': '\\ql'
                        };
                        if (alignMap[attributes.align]) {
                            paragraphBuffer += alignMap[attributes.align];
                        }
                    } else {
                        // Default to left alignment
                        paragraphBuffer += '\\ql';
                    }
                    
                    // Apply additional paragraph formatting as needed
                    paragraphBuffer += ' ';
                    
                    // Process each text run in the paragraph
                    for (let i = 0; i < ops.length; i++) {
                        const op = ops[i];
                        if (typeof op.insert !== 'string') continue;
                        
                        let text = op.insert;
                        if (!text) continue;
                        
                        // Handle special RTF characters
                        text = text.replace(/\\/g, '\\\\')
                            .replace(/\{/g, '\\{')
                            .replace(/\}/g, '\\}')
                            .replace(/\r/g, '')
                            .replace(/\n/g, '\\line ')
                            .replace(/([^\u0000-\u007F])/g, function(match) {
                                return '\\u' + match.charCodeAt(0) + '?';
                            });
                        
                        let textPrefix = '';
                        let textSuffix = '';
                        
                        if (op.attributes) {
                            // Font family
                            if (op.attributes.font) {
                                const fontName = op.attributes.font.toLowerCase();
                                const fontIndex = fontMap[fontName] !== undefined 
                                    ? fontMap[fontName] 
                                    : fontMap.default;
                                textPrefix += `\\f${fontIndex} `;
                            } else if (headerLevel) {
                                // Use header font if no specific font and we're in a header
                                textPrefix += '\\f1 '; // Arial-Bold for headers
                            } else {
                                // Default font
                                textPrefix += '\\f0 '; // Arial
                            }
                            
                            // Font size
                            if (op.attributes.size) {
                                const sizeMap = {
                                    'small': '\\fs18',
                                    'large': '\\fs32',
                                    'huge': '\\fs40'
                                };
                                
                                if (sizeMap[op.attributes.size]) {
                                    textPrefix += sizeMap[op.attributes.size] + ' ';
                                    textSuffix = '\\fs24 ' + textSuffix;
                                }
                            } else if (headerLevel) {
                                // Apply header font size based on level if no specific size
                                const headerSizeMap = {
                                    1: '\\fs40',
                                    2: '\\fs36',
                                    3: '\\fs32',
                                    4: '\\fs28',
                                    5: '\\fs24',
                                    6: '\\fs22'
                                };
                                if (headerSizeMap[headerLevel]) {
                                    textPrefix += headerSizeMap[headerLevel] + ' ';
                                }
                            } else {
                                // Default size
                                textPrefix += '\\fs24 ';
                            }
                            
                            // Bold
                            if (op.attributes.bold || headerLevel) {
                                textPrefix += '\\b ';
                                textSuffix = '\\b0 ' + textSuffix;
                            }
                            
                            // Italic
                            if (op.attributes.italic || (headerLevel && headerLevel >= 5)) {
                                textPrefix += '\\i ';
                                textSuffix = '\\i0 ' + textSuffix;
                            }
                            
                            // Underline
                            if (op.attributes.underline) {
                                textPrefix += '\\ul ';
                                textSuffix = '\\ulnone ' + textSuffix;
                            }
                            
                            // Strike-through
                            if (op.attributes.strike) {
                                textPrefix += '\\strike ';
                                textSuffix = '\\strike0 ' + textSuffix;
                            }
                            
                            // Text color
                            if (op.attributes.color) {
                                // Map common colors
                                const colorMap = {
                                    'red': '\\cf3',
                                    'blue': '\\cf4',
                                    'green': '\\cf5',
                                    'black': '\\cf2',
                                    'white': '\\cf1'
                                };
                                
                                if (colorMap[op.attributes.color]) {
                                    textPrefix += colorMap[op.attributes.color] + ' ';
                                    textSuffix = '\\cf0 ' + textSuffix;
                                }
                            }
                            
                            // Background color
                            if (op.attributes.background) {
                                textPrefix += '\\highlight3 ';
                                textSuffix = '\\highlight0 ' + textSuffix;
                            }
                            
                            // Now write the formatted text
                            paragraphBuffer += `${textPrefix}${text}${textSuffix}`;
                        } else {
                            // No direct formatting, but may inherit from paragraph level
                            if (headerLevel) {
                                // Use header formatting
                                const headerSizeMap = {
                                    1: '\\fs40',
                                    2: '\\fs36',
                                    3: '\\fs32',
                                    4: '\\fs28',
                                    5: '\\fs24',
                                    6: '\\fs22'
                                };
                                
                                let headerPrefix = '\\f1 ' + headerSizeMap[headerLevel] + ' \\b ';
                                let headerSuffix = '\\b0';
                                
                                if (headerLevel >= 5) {
                                    headerPrefix += '\\i ';
                                    headerSuffix = '\\i0 ' + headerSuffix;
                                }
                                
                                paragraphBuffer += `${headerPrefix}${text}${headerSuffix}`;
                            } else {
                                // Normal paragraph text
                                paragraphBuffer += `\\f0 \\fs24 ${text}`;
                            }
                        }
                    }
                    
                    // End the paragraph
                    paragraphBuffer += '\\par\n';
                    
                    return paragraphBuffer;
                }
                
                // Add the buffer to the RTF document
                rtf += buffer;
                
                // Close RTF document
                rtf += '}';
                
                return rtf;
            }
            
            // Helper function to convert Quill content to DOCX format
            function convertToDocx(quillContent) {
                // This is a simplified DOCX generator that preserves basic formatting
                // For a real-world implementation, you'd want to use a library like docx.js
                
                // Create minimal Office Open XML file structure
                const xmlHeader = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>';
                
                // Main document.xml content
                let documentXml = xmlHeader + 
                    '<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">' +
                    '<w:body>';
                
                // Process the Delta content
                let paragraphText = '';
                let paragraphFormats = [];
                
                quillContent.ops.forEach(op => {
                    if (typeof op.insert === 'string') {
                        const text = op.insert;
                        
                        // Handle paragraph breaks
                        if (text === '\n') {
                            // Complete current paragraph and start a new one
                            if (paragraphText.length > 0 || paragraphFormats.length > 0) {
                                documentXml += createDocxParagraph(paragraphText, paragraphFormats);
                                paragraphText = '';
                                paragraphFormats = [];
                            } else {
                                // Empty paragraph
                                documentXml += '<w:p><w:pPr></w:pPr></w:p>';
                            }
                        } else {
                            // Handle formatting for this text run
                            const formats = [];
                            if (op.attributes) {
                                if (op.attributes.bold) formats.push('bold');
                                if (op.attributes.italic) formats.push('italic');
                                if (op.attributes.underline) formats.push('underline');
                                if (op.attributes.strike) formats.push('strike');
                                if (op.attributes.background) formats.push('highlight');
                                if (op.attributes.color) formats.push('color:' + op.attributes.color);
                            }
                            
                            // Add text with position and format info to current paragraph
                            paragraphFormats.push({
                                startPos: paragraphText.length,
                                endPos: paragraphText.length + text.length,
                                formats: formats
                            });
                            paragraphText += text;
                        }
                    }
                });
                
                // Add any remaining paragraph
                if (paragraphText.length > 0) {
                    documentXml += createDocxParagraph(paragraphText, paragraphFormats);
                }
                
                // Close document
                documentXml += '</w:body></w:document>';
                
                // In a real implementation, we would create a ZIP file with the proper DOCX structure
                // For simplicity in this demo, we'll just return the document XML
                return documentXml;
            }
            
            function createDocxParagraph(text, formats) {
                let paragraph = '<w:p><w:pPr></w:pPr>';
                
                // If no formats, just add the text as a single run
                if (formats.length === 0) {
                    paragraph += `<w:r><w:t>${escapeXml(text)}</w:t></w:r>`;
                } else {
                    // Create sorted format boundaries
                    const boundaries = [];
                    formats.forEach(format => {
                        if (!boundaries.includes(format.startPos)) {
                            boundaries.push(format.startPos);
                        }
                        if (!boundaries.includes(format.endPos)) {
                            boundaries.push(format.endPos);
                        }
                    });
                    boundaries.sort((a, b) => a - b);
                    
                    // Create runs for each segment
                    for (let i = 0; i < boundaries.length - 1; i++) {
                        const start = boundaries[i];
                        const end = boundaries[i + 1];
                        const segment = text.substring(start, end);
                        
                        // Get formats that apply to this segment
                        const activeFormats = formats.filter(f => 
                            f.startPos <= start && f.endPos >= end
                        ).map(f => f.formats).flat();
                        
                        // Create run with proper formatting
                        paragraph += createFormattedRun(segment, activeFormats);
                    }
                }
                
                paragraph += '</w:p>';
                return paragraph;
            }
            
            function createFormattedRun(text, formats) {
                let run = '<w:r><w:rPr>';
                
                // Apply formatting
                if (formats.includes('bold')) {
                    run += '<w:b/>';
                }
                if (formats.includes('italic')) {
                    run += '<w:i/>';
                }
                if (formats.includes('underline')) {
                    run += '<w:u w:val="single"/>';
                }
                if (formats.includes('strike')) {
                    run += '<w:strike/>';
                }
                if (formats.includes('highlight')) {
                    run += '<w:highlight w:val="yellow"/>'; // Default to yellow highlight
                }
                
                // Handle text color
                const colorFormat = formats.find(f => f.startsWith('color:'));
                if (colorFormat) {
                    const color = colorFormat.split(':')[1];
                    // Convert color name to hex (simplified)
                    const colorHex = getColorHex(color);
                    run += `<w:color w:val="${colorHex}"/>`;
                }
                
                run += '</w:rPr><w:t>';
                
                // Special handling for spaces at start/end to preserve them
                if (text.startsWith(' ') || text.endsWith(' ')) {
                    run += '<w:t xml:space="preserve">';
                } else {
                    run += '<w:t>';
                }
                
                run += escapeXml(text) + '</w:t></w:r>';
                return run;
            }
            
            function escapeXml(text) {
                return text
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&apos;');
            }
            
            function getColorHex(colorName) {
                // Map of common color names to hex values
                const colorMap = {
                    'black': '000000',
                    'white': 'FFFFFF',
                    'red': 'FF0000',
                    'green': '00FF00',
                    'blue': '0000FF',
                    'yellow': 'FFFF00',
                    'purple': '800080'
                };
                
                return colorMap[colorName] || '000000'; // Default to black
            }
            
            // Add keyboard shortcut listeners (Ctrl+Z, Ctrl+Shift+Z, Cmd+Z, Cmd+Shift+Z)
            document.addEventListener('keydown', function(e) {
                // Check if we're inside an input or textarea element (but allow our contenteditable)
                const targetIsInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA';
                if (targetIsInput) return; // Don't override normal input behavior
                
                const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                const cmdKey = isMac ? e.metaKey : e.ctrlKey;
                
                if (cmdKey && e.shiftKey && e.key.toLowerCase() === 'z') {
                    // Cmd/Ctrl+Shift+Z = Redo
                    e.preventDefault();
                    quill.history.redo();
                } else if (cmdKey && !e.shiftKey && e.key.toLowerCase() === 'z') {
                    // Cmd/Ctrl+Z = Undo
                    e.preventDefault();
                    quill.history.undo();
                }
            });
            
            // Initial update
            updateTextStats();
            
            // Save initial editor contents for format preservation
            saveEditorContents();
            
            // Automatically run Density analysis when page loads
            setTimeout(() => {
                // Run full analyzeDensity to properly count and process words
                const text = getEditableText();
                if (text) {
                    analyzeDensity(text);
                }
            }, 200);
            
            // Tab switching functionality with complete highlight clearing
            const tabs = document.querySelectorAll('.tab-link');
            tabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    // Get current and new tab IDs
                    const previousTab = document.querySelector('.tab-link.active').dataset.tab;
                    const newTab = this.dataset.tab;
                    
                    // Skip if clicking the already active tab
                    if (previousTab === newTab) return;
                    
                    console.log(`Switching from ${previousTab} to ${newTab}`);
                    
                    // First, get raw text content (we'll maintain this)
                    const rawText = getEditableText();
                    
                    // Save user formatting (bold, italic, RTL, etc.) before tab switch
                    saveEditorContents();
                    
                    // AGGRESSIVELY CLEAR ALL HIGHLIGHTS
                    // 1. First, apply the clean version without any highlights
                    if (userFormattedContents) {
                        console.log("Applying clean content without highlights");
                        quill.setContents(userFormattedContents);
                    }
                    
                    // 2. Directly delete all background formatting to be even more thorough
                    const contents = quill.getContents();
                    if (contents && contents.ops) {
                        // Create a copy with all background and color formatting removed
                        const cleanedContents = JSON.parse(JSON.stringify(contents));
                        cleanedContents.ops.forEach(op => {
                            if (op.attributes) {
                                delete op.attributes.background;
                                delete op.attributes.color;
                                // Clean up empty attributes objects
                                if (Object.keys(op.attributes).length === 0) {
                                    delete op.attributes;
                                }
                            }
                        });
                        
                        // Apply the aggressively cleaned content
                        quill.setContents(cleanedContents);
                        
                        // Update our clean copy
                        userFormattedContents = cleanedContents;
                    }
                    
                    // Update UI tab state
                    tabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update tab content visibility
                    const tabContents = document.querySelectorAll('.tab-content');
                    tabContents.forEach(content => content.classList.remove('active'));
                    const targetTab = document.getElementById(this.dataset.tab);
                    targetTab.classList.add('active');
                    
                    // Hide all warning messages when switching tabs
                    document.getElementById('configChangedAlert').classList.add('hidden');
                    document.getElementById('noActiveSetsWarning').classList.add('hidden');
                    document.getElementById('noElementsWarning').classList.add('hidden');
                    document.getElementById('noCustomMatchesWarning').classList.add('hidden');
                    
                    // Remove any Letter % Match error messages when switching tabs
                    const letterMatchErrors = document.querySelectorAll('.letter-match-error');
                    letterMatchErrors.forEach(error => error.remove());
                    
                    // Remove density summary when not in Density tab
                    if (newTab !== 'densityTab') {
                        const existingSummary = document.querySelector('.mt-4.p-2.bg-gray-100');
                        if (existingSummary) existingSummary.remove();
                    }
                    
                    // Now run tab-specific logic with clean content
                    
                    // Special handling for Density tab
                    if (newTab === 'densityTab') {
                        // Check if the text has changed since last analysis
                        if (rawText !== lastDensityText) {
                            analyzeDensity(rawText);
                        } else {
                            // The text hasn't changed, just set up UI and update word list
                            const exactWords = document.getElementById('includeDerivatives').checked;
                            const similarityThreshold = parseInt(document.getElementById('similarityThreshold').value);
                            const thresholdSlider = document.getElementById('similarityThreshold');
                            
                            // Apply correct state to threshold slider
                            if (exactWords) {
                                thresholdSlider.disabled = true;
                                thresholdSlider.classList.add('opacity-50');
                            } else {
                                thresholdSlider.disabled = false;
                                thresholdSlider.classList.remove('opacity-50');
                            }
                            
                            // Only update the word list if we have analyzed text
                            if (currentAnalyzedText) {
                                updateWordDensityResults(similarityThreshold, !exactWords);
                                
                                // Make sure a word is selected when returning to the tab
                                setTimeout(() => {
                                    selectFirstWordItem();
                                }, 50);
                            }
                        }
                    }
                    // Special handling for Rhythm tab
                    else if (newTab === 'rhythmTab') {
                        // Update the content for rhythm analysis
                        originalTextContent = rawText;
                        // Run rhythm analysis
                        analyzeRhythm();
                    }
                    // Auto-analyze when switching to Homonym Patterns tab
                    else if (newTab === 'homonymPatternsTab') {
                        if (rawText) {
                            // Automatically run homonym patterns analysis
                            analyzeHomonymPatterns();
                        }
                    }
                    // Handle other tabs
                    else {
                        if (rawText) {
                            if (newTab === 'pronounsTab') {
                                analyzePronouns(rawText);
                            } else if (newTab === 'homophonesTab') {
                                analyzeHomonyms();
                            } else if (newTab === 'customSetsTab') {
                                analyzeCustomSets(rawText);
                            }
                        }
                    }
                    
                    // Update last active tab
                    lastActiveTab = newTab;
                });
            });
            
            // Initialize Word Pattern Configuration controls
            function initWordPatternControls() {
                // 1. Word Location Buttons
                const locationButtons = document.querySelectorAll('.location-button');
                const locationDescription = document.getElementById('locationDescription');
                
                // Location description texts
                const locationDescriptions = {
                    'startSame': 'Beginning of the first word matches the start of the next match',
                    'endSame': 'End of the first word matches the end of the next match',
                    'endStartMatch': 'End of the first word matches the beginning of the next match'
                };
                
                // Add click event to buttons
                locationButtons.forEach(button => {
                    button.addEventListener('click', function() {
                        // Remove active class from all buttons
                        locationButtons.forEach(btn => {
                            btn.classList.remove('active');
                        });
                        
                        // Add active class to clicked button
                        this.classList.add('active');
                        
                        // Update description text
                        locationDescription.textContent = locationDescriptions[this.dataset.value];
                        
                        // Show configuration changed alert if needed
                        if (hasAnalyzedHomonyms) {
                            document.getElementById('configChangedAlert').classList.remove('hidden');
                            configurationChanged = true;
                        }
                    });
                });
                
                // 2. Words in Between Slider
                const wordsBetweenSlider = document.getElementById('wordsBetweenSlider');
                
                // Display formatted value
                function updateWordsBetweenValue() {
                    // Now displayed directly to reduce ID references
                    const value = wordsBetweenSlider.value;
                    wordsBetweenSlider.nextElementSibling.nextElementSibling.textContent = value;
                }
                
                wordsBetweenSlider.addEventListener('input', function() {
                    updateWordsBetweenValue();
                    
                    // Show configuration changed alert if needed
                    if (hasAnalyzedHomonyms) {
                        document.getElementById('configChangedAlert').classList.remove('hidden');
                        configurationChanged = true;
                    }
                });
                
                updateWordsBetweenValue();
                
                // 3. Letters to Match Slider
                const lettersToMatchSlider = document.getElementById('lettersToMatchSlider');
                
                // Letters to Match also interacts with the Letter % Match options
                function updateLettersToMatchValue() {
                    const value = lettersToMatchSlider.value;
                    const oneLetterOptions = document.getElementById('oneLetterMatchOptions');
                    const twoLetterOptions = document.getElementById('twoLetterMatchOptions');
                    const threeLetterOptions = document.getElementById('threeLetterMatchOptions');
                    const fourLetterOptions = document.getElementById('fourLetterMatchOptions');
                    
                    // Display formatted value - simple number only
                    lettersToMatchSlider.nextElementSibling.nextElementSibling.textContent = value;
                    
                    // Update Letter Match % options visibility
                    oneLetterOptions.classList.add('hidden');
                    twoLetterOptions.classList.add('hidden');
                    threeLetterOptions.classList.add('hidden');
                    fourLetterOptions.classList.add('hidden');
                    
                    // Show relevant options based on selection
                    if (value === '1') {
                        oneLetterOptions.classList.remove('hidden');
                        document.getElementById('match100Percent').checked = true;
                    } else if (value === '2') {
                        oneLetterOptions.classList.remove('hidden');
                        twoLetterOptions.classList.remove('hidden');
                    } else if (value === '3') {
                        oneLetterOptions.classList.remove('hidden');
                        threeLetterOptions.classList.remove('hidden');
                    } else if (value === '4') {
                        oneLetterOptions.classList.remove('hidden');
                        fourLetterOptions.classList.remove('hidden');
                    }
                }
                
                lettersToMatchSlider.addEventListener('input', function() {
                    updateLettersToMatchValue();
                    
                    // Check if percentage match needs to be reselected
                    const selectedPercentage = document.querySelector('input[name="matchPercent"]:checked');
                    const selectedPercentValue = selectedPercentage ? selectedPercentage.value : null;
                    
                    // If the percentage is not 100%, require user to select a new value
                    if (selectedPercentValue !== "100") {
                        // Show validation message
                        const letterPercentMatch = document.getElementById('letterPercentMatch');
                        
                        // Remove any existing error message
                        const existingError = letterPercentMatch.querySelector('.letter-match-error');
                        if (existingError) {
                            existingError.remove();
                        }
                        
                        // Add error message
                        const errorMsg = document.createElement('div');
                        errorMsg.className = 'letter-match-error text-red-600 dark:text-red-400 text-sm mt-1';
                        errorMsg.textContent = 'Select a value for the new letters count';
                        letterPercentMatch.appendChild(errorMsg);
                        
                        // Uncheck all radio buttons to force selection
                        document.querySelectorAll('input[name="matchPercent"]').forEach(radio => {
                            radio.checked = false;
                        });
                    }
                    
                    // Show configuration changed alert if needed
                    if (hasAnalyzedHomonyms) {
                        document.getElementById('configChangedAlert').classList.remove('hidden');
                        configurationChanged = true;
                    }
                });
                
                updateLettersToMatchValue();
                
                // 4. Letter Order radio buttons
                const letterOrderRadios = document.querySelectorAll('input[name="letterOrder"]');
                letterOrderRadios.forEach(radio => {
                    radio.addEventListener('change', function() {
                        // Show configuration changed alert if needed
                        if (hasAnalyzedHomonyms) {
                            document.getElementById('configChangedAlert').classList.remove('hidden');
                            configurationChanged = true;
                        }
                    });
                });
                
                // 5. Match Percent radio buttons
                const matchPercentRadios = document.querySelectorAll('input[name="matchPercent"]');
                matchPercentRadios.forEach(radio => {
                    radio.addEventListener('change', function() {
                        // Remove any existing error message when a selection is made
                        const letterPercentMatch = document.getElementById('letterPercentMatch');
                        const existingError = letterPercentMatch.querySelector('.letter-match-error');
                        if (existingError) {
                            existingError.remove();
                        }
                        
                        // Show configuration changed alert if needed
                        if (hasAnalyzedHomonyms) {
                            document.getElementById('configChangedAlert').classList.remove('hidden');
                            configurationChanged = true;
                        }
                    });
                });
                
                // Set exact order radio button as default
                document.getElementById('exactOrderRadio').checked = true;
            }
            
            // Analyze button functionality (main button and all tab-specific buttons)
            document.getElementById('analyzeBtn').addEventListener('click', function() {
                analyzeText('homophonesTab');
            });
            
            // Add click events to all other analyze buttons in other tabs
            document.querySelectorAll('.analyze-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const activeTab = document.querySelector('.tab-link.active').dataset.tab;
                    analyzeText(activeTab);
                });
            });
            
            // Add event listener for Rhythm analyze button
            document.getElementById('analyzeRhythmBtn').addEventListener('click', function() {
                analyzeText('rhythmTab');
            });
            
            // Add event listener for Homonym Patterns analyze button
            document.getElementById('analyzeHomonymBtn').addEventListener('click', function() {
                analyzeText('homonymPatternsTab');
            });
            
            // Homonym Patterns functionality
            let hasAnalyzedHomonymPatterns = false;
            let homonymConfigurationChanged = false;
            
            // Setup homonym location buttons
            const homonymLocationButtons = document.querySelectorAll('.homonym-location-button');
            const homonymLocationDescription = document.getElementById('homonymLocationDescription');
            
            // Location description texts for homonym patterns
            const homonymLocationDescriptions = {
                'startStart': 'Start of the first word pattern matches the start of the next match pattern',
                'endEnd': 'End of the first word pattern matches the end pattern of the next match',
                'endStart': 'End of the first word pattern matches the beginning pattern of the next match'
            };
            
            // Add click event to homonym location buttons
            homonymLocationButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    homonymLocationButtons.forEach(btn => {
                        btn.classList.remove('active');
                        // Reset border styling completely
                        btn.style.borderColor = 'transparent';
                        btn.style.backgroundColor = '';
                        btn.style.color = '';
                    });
                    
                    // Add active class to clicked button and update styles to match other location buttons
                    this.classList.add('active');
                    this.style.borderColor = '#5D5CDE';
                    this.style.backgroundColor = '#5D5CDE';
                    this.style.color = 'white';
                    
                    // Update description text
                    homonymLocationDescription.textContent = homonymLocationDescriptions[this.dataset.value];
                    
                    // Show configuration changed alert if needed
                    if (hasAnalyzedHomonymPatterns) {
                        document.getElementById('homonymConfigChangedAlert').classList.remove('hidden');
                        homonymConfigurationChanged = true;
                    }
                });
            });
            
            // Words in Between Slider for homonym patterns
            const homonymWordsBetweenSlider = document.getElementById('homonymWordsBetweenSlider');
            
            function updateHomonymWordsBetweenValue() {
                const value = homonymWordsBetweenSlider.value;
                homonymWordsBetweenSlider.nextElementSibling.nextElementSibling.textContent = value;
            }
            
            homonymWordsBetweenSlider.addEventListener('input', function() {
                updateHomonymWordsBetweenValue();
                
                // Show configuration changed alert if needed
                if (hasAnalyzedHomonymPatterns) {
                    document.getElementById('homonymConfigChangedAlert').classList.remove('hidden');
                    homonymConfigurationChanged = true;
                }
            });
            
            updateHomonymWordsBetweenValue();
            
            // Homonym patterns localStorage functionality
            // Function to save homonym groups to localStorage
            function saveHomonymGroupsToLocalStorage() {
                try {
                    const homonymGroupsText = document.getElementById('homonymGroupsInput').value.trim();
                    const usePredefinedPatterns = document.getElementById('usePredefinedPatterns').checked;
                    
                    // Parse the homonym groups
                    const groups = homonymGroupsText.split('\n')
                        .map(line => line.trim())
                        .filter(line => line.length > 0);
                    
                    // Create a data object to store
                    const homonymData = {
                        homonymGroups: groups,
                        usePredefinedPatterns: usePredefinedPatterns,
                        savedDate: new Date().toISOString()
                    };
                    
                    // Save to localStorage
                    localStorage.setItem('wordPatternAnalyzerHomonymGroups', JSON.stringify(homonymData));
                } catch (error) {
                    console.error('Error saving homonym groups to localStorage:', error);
                }
            }
            
            // Function to load homonym groups from localStorage
            function loadHomonymGroupsFromLocalStorage() {
                try {
                    const savedData = localStorage.getItem('wordPatternAnalyzerHomonymGroups');
                    if (savedData) {
                        const homonymData = JSON.parse(savedData);
                        
                        // Validate imported data
                        if (homonymData && homonymData.homonymGroups) {
                            // Apply the saved homonym groups
                            document.getElementById('homonymGroupsInput').value = homonymData.homonymGroups.join('\n');
                            
                            // Set the predefined patterns checkbox if it was saved
                            if (homonymData.usePredefinedPatterns !== undefined) {
                                document.getElementById('usePredefinedPatterns').checked = homonymData.usePredefinedPatterns;
                                
                                // Update predefined patterns container visibility
                                const container = document.getElementById('predefinedPatternsContainer');
                                container.style.opacity = homonymData.usePredefinedPatterns ? '1' : '0.5';
                            }
                            
                            console.log(`Loaded ${homonymData.homonymGroups.length} homonym groups from localStorage`);
                        }
                    }
                } catch (error) {
                    console.error('Error loading homonym groups from localStorage:', error);
                }
            }
            
            // Listen for changes to the homonym groups and save to localStorage
            document.getElementById('homonymGroupsInput').addEventListener('change', saveHomonymGroupsToLocalStorage);
            document.getElementById('usePredefinedPatterns').addEventListener('change', saveHomonymGroupsToLocalStorage);
            
            // Load saved homonym groups when the page loads
            loadHomonymGroupsFromLocalStorage();
            
            // Setup homonym groups reading/editing mode functionality
            function setupHomonymGroupsReadEditMode() {
                // Initially populate read view from textarea content
                updateHomonymGroupsReadView();
                
                // Add click event listener for edit button
                document.getElementById('editHomonymGroupsBtn').addEventListener('click', function() {
                    // Switch to edit mode
                    document.getElementById('homonymGroupsReadView').classList.add('hidden');
                    document.getElementById('homonymGroupsEditView').classList.remove('hidden');
                    
                    // Make the textarea editable
                    const textarea = document.getElementById('homonymGroupsInput');
                    textarea.removeAttribute('readonly');
                    textarea.focus();
                });
                
                // Add click event for cancel button
                document.getElementById('cancelHomonymEditBtn').addEventListener('click', function() {
                    // Switch back to read mode without saving changes
                    document.getElementById('homonymGroupsEditView').classList.add('hidden');
                    document.getElementById('homonymGroupsReadView').classList.remove('hidden');
                    
                    // Restore the original content from localStorage
                    const textarea = document.getElementById('homonymGroupsInput');
                    const savedData = localStorage.getItem('wordPatternAnalyzerHomonymGroups');
                    if (savedData) {
                        try {
                            const homonymData = JSON.parse(savedData);
                            if (homonymData && homonymData.homonymGroups) {
                                textarea.value = homonymData.homonymGroups.join('\n');
                            }
                        } catch (error) {
                            console.error('Error restoring homonym groups:', error);
                        }
                    }
                    
                    // Make the textarea readonly again
                    textarea.setAttribute('readonly', 'readonly');
                });
                
                // Add click event for save button
                document.getElementById('saveHomonymGroupsBtn').addEventListener('click', function() {
                    // Save to localStorage
                    saveHomonymGroupsToLocalStorage();
                    
                    // Update the read view
                    updateHomonymGroupsReadView();
                    
                    // Switch back to read mode
                    document.getElementById('homonymGroupsEditView').classList.add('hidden');
                    document.getElementById('homonymGroupsReadView').classList.remove('hidden');
                    
                    // Make the textarea readonly again
                    document.getElementById('homonymGroupsInput').setAttribute('readonly', 'readonly');
                    
                    // Show configuration changed alert if needed
                    if (hasAnalyzedHomonymPatterns) {
                        document.getElementById('homonymConfigChangedAlert').classList.remove('hidden');
                        homonymConfigurationChanged = true;
                    }
                });
            }
            
            // Function to update the read view content
            function updateHomonymGroupsReadView() {
                const textareaContent = document.getElementById('homonymGroupsInput').value;
                document.getElementById('homonymGroupsContent').textContent = textareaContent;
            }
            
            // Initialize reading/editing mode
            setupHomonymGroupsReadEditMode();
            
            // Import/Export functionality for homonym patterns
            document.getElementById('exportHomonymGroupsBtn').addEventListener('click', exportHomonymGroups);
            document.getElementById('importHomonymGroupsBtn').addEventListener('click', importHomonymGroups);
            
            function exportHomonymGroups() {
                const homonymGroupsText = document.getElementById('homonymGroupsInput').value.trim();
                if (!homonymGroupsText) {
                    alert('You don\'t have any homonym groups to export.');
                    return;
                }
                
                // Parse the homonym groups
                const groups = homonymGroupsText.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0);
                
                // Include whether predefined patterns are enabled
                const usePredefinedPatterns = document.getElementById('usePredefinedPatterns').checked;
                
                const exportData = {
                    homonymGroups: groups,
                    usePredefinedPatterns: usePredefinedPatterns,
                    exportDate: new Date().toISOString(),
                    appVersion: '1.0'
                };
                
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create export dialog
                const exportDialog = document.createElement('div');
                exportDialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                exportDialog.innerHTML = `
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg max-w-md w-full">
                        <h3 class="text-lg font-semibold mb-4">Export Homonym Groups</h3>
                        <p class="mb-4">Your browser's security settings prevent direct file downloads. Please:</p>
                        <ol class="list-decimal pl-5 mb-4 space-y-2">
                            <li>Right-click the link below</li>
                            <li>Select "Save link as" or similar option</li>
                            <li>Save the file to your computer</li>
                        </ol>
                        <div class="mb-4">
                            <a href="${url}" target="_blank" class="text-indigo-600 hover:text-indigo-800 dark:text-indigo-400 dark:hover:text-indigo-300 underline font-medium">homonym-groups.json</a>
                        </div>
                        <button class="close-export-dialog w-full bg-gray-300 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-white font-medium py-2 px-4 rounded">Close</button>
                    </div>
                `;
                document.body.appendChild(exportDialog);
                
                // Add close functionality
                exportDialog.querySelector('.close-export-dialog').addEventListener('click', function() {
                    exportDialog.remove();
                    URL.revokeObjectURL(url);
                });
            }
            
            function importHomonymGroups() {
    // Create a file input element
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.json,application/json';
    
    fileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const importData = JSON.parse(e.target.result);
                
                // Validate import data
                if (!importData.homonymGroups || !Array.isArray(importData.homonymGroups)) {
                    throw new Error('Invalid import file format');
                }
                
                // Get current homonym groups from textarea
                const textarea = document.getElementById('homonymGroupsInput');
                const currentGroups = textarea.value.trim()
                    .split('\n')
                    .filter(line => line.trim().length > 0);
                
                // Create a set to track unique groups and avoid duplicates
                const uniqueGroupsSet = new Set(currentGroups);
                
                // Count how many new groups will be added (not duplicates)
                let newGroupCount = 0;
                importData.homonymGroups.forEach(group => {
                    if (!uniqueGroupsSet.has(group)) {
                        uniqueGroupsSet.add(group);
                        newGroupCount++;
                    }
                });
                
                // Get confirmation to add the groups (not replace)
                const message = currentGroups.length > 0 ? 
                    `Add ${newGroupCount} new group(s) to your existing ${currentGroups.length} group(s)? ${newGroupCount === 0 ? '(No new groups found)' : ''}` :
                    `Import ${importData.homonymGroups.length} group(s)?`;
                
                if (!confirm(message)) {
                    return;
                }
                
                // Combine existing and imported groups, removing duplicates
                const combinedGroups = [...uniqueGroupsSet];
                
                // Apply to textarea
                textarea.value = combinedGroups.join('\n');
                
                // Apply predefined patterns setting if present in import
                if (importData.usePredefinedPatterns !== undefined) {
                    document.getElementById('usePredefinedPatterns').checked = importData.usePredefinedPatterns;
                    
                    // Update predefined patterns container visibility
                    const container = document.getElementById('predefinedPatternsContainer');
                    container.style.opacity = importData.usePredefinedPatterns ? '1' : '0.5';
                }
                
                // Save the imported data to localStorage
                saveHomonymGroupsToLocalStorage();
                
                // Update the read-only view to show the imported groups immediately
                updateHomonymGroupsReadView();
                
                // Show success message
                alert(`Successfully added ${newGroupCount} new homonym groups!`);
                
                // Show config changed alert if needed
                if (hasAnalyzedHomonymPatterns) {
                    document.getElementById('homonymConfigChangedAlert').classList.remove('hidden');
                    homonymConfigurationChanged = true;
                }
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing homonym groups: ' + error.message);
            }
        };
        
        reader.readAsText(file);
    });
    
    // Trigger file selection
    fileInput.click();
}
            
            // Predefined sound patterns
            const predefinedPatterns = [
                ["ai", "ay"],
                ["ee", "ea", "ie", "y"],
                ["igh", "ie", "y"],
                ["oat", "ow", "ould"],
                ["oo", "ue", "ew"],
                ["oi", "oy"],
                ["ur", "urn", "er"],
                ["awe", "ove", "aw", "or"],
                ["ph", "f"],
                ["ch", "tch"],
                ["wh", "w"],
                ["kn", "n"],
                ["wr", "r"],
                ["mb", "m"],
                ["tion", "sion"]
            ];
            
            // Add event listener for Predefined Patterns toggle
            document.getElementById('usePredefinedPatterns').addEventListener('change', function() {
                // Show configuration changed alert if needed
                if (hasAnalyzedHomonymPatterns) {
                    document.getElementById('homonymConfigChangedAlert').classList.remove('hidden');
                    homonymConfigurationChanged = true;
                }
                
                // Update predefined patterns container visibility
                const container = document.getElementById('predefinedPatternsContainer');
                container.style.opacity = this.checked ? '1' : '0.5';
            });
            
            // Function to analyze homonym patterns based on user input
            function analyzeHomonymPatterns() {
                // Save current formatting
                saveEditorContents();
                
                // Get text and validate
                const text = getEditableText();
                if (!text) {
                    alert('Please enter some text to analyze.');
                    return;
                }
                
                // Reset configuration changed flag
                homonymConfigurationChanged = false;
                document.getElementById('homonymConfigChangedAlert').classList.add('hidden');
                
                // Set flag to indicate we've analyzed
                hasAnalyzedHomonymPatterns = true;
                
                // First, clear any existing highlights by applying clean content
                if (userFormattedContents) {
                    quill.setContents(userFormattedContents);
                }
                
                // Get configuration options
                const patternLocation = document.querySelector('.homonym-location-button.active').dataset.value;
                const wordsBetween = parseInt(document.getElementById('homonymWordsBetweenSlider').value);
                const usePredefined = document.getElementById('usePredefinedPatterns').checked;
                
                // Get all homonym groups to analyze
                const homonymGroups = [];
                
                // Add predefined patterns if enabled
                if (usePredefined) {
                    homonymGroups.push(...predefinedPatterns);
                }
                
                // Get homonym groups from textarea
                const homonymGroupsText = document.getElementById('homonymGroupsInput').value.trim();
                
                // Parse custom homonym groups
                if (homonymGroupsText) {
                    homonymGroupsText.split('\n').forEach(line => {
                        const line_trimmed = line.trim();
                        if (line_trimmed) {
                            const patterns = line_trimmed.split(',').map(pattern => pattern.trim()).filter(pattern => pattern.length > 0);
                            if (patterns.length >= 2) {
                                homonymGroups.push(patterns);
                            }
                        }
                    });
                }
                
                // Check if we have any patterns to analyze
                if (homonymGroups.length === 0) {
                    const resultsList = document.getElementById('homonymResultsList');
                    resultsList.innerHTML = '<div class="text-center text-red-500 italic">No valid homonym pattern groups found. Please enable predefined patterns or add custom patterns.</div>';
                    return;
                }
                
                // Tokenize text
                const textTokens = text.split(/\s+/).filter(word => word.length > 0);
                
                // Process words for analysis
                const processedWords = textTokens.map(token => {
                    return token.replace(/[^\p{L}\p{N}]/gu, '').toLowerCase();
                });
                
                // Store matched pairs with their positions
                const matchPairs = [];
                
                // For each homonym group, find matches in the text
                for (let i = 0; i < processedWords.length; i++) {
                    const currentWord = processedWords[i];
                    if (!currentWord) continue; // Skip empty processed words
                    
                    // Calculate target index based on words between
                    const targetIndex = i + wordsBetween + 1;
                    
                    // Check if target index is within bounds
                    if (targetIndex < processedWords.length) {
                        const targetWord = processedWords[targetIndex];
                        if (!targetWord) continue; // Skip empty processed words
                        
                        // Check each homonym group for matches
                        for (const group of homonymGroups) {
                            // Check all pairs of patterns within the group
                            for (let patternIndex = 0; patternIndex < group.length; patternIndex++) {
                                const pattern1 = group[patternIndex];
                                
                                // Compare with all other patterns in the group
                                for (let otherPatternIndex = 0; otherPatternIndex < group.length; otherPatternIndex++) {
                                    // Skip comparing pattern with itself
                                    if (patternIndex === otherPatternIndex) continue;
                                    
                                    const pattern2 = group[otherPatternIndex];
                                    
                                    // Check for matches based on pattern location
                                    let match = false;
                                    if (patternLocation === 'startStart') {
                                        // Start of first word matches start of second word
                                        if (currentWord.startsWith(pattern1) && targetWord.startsWith(pattern2)) {
                                            match = true;
                                        }
                                    } else if (patternLocation === 'endEnd') {
                                        // End of first word matches end of second word
                                        if (currentWord.endsWith(pattern1) && targetWord.endsWith(pattern2)) {
                                            match = true;
                                        }
                                    } else if (patternLocation === 'endStart') {
                                        // End of first word matches start of second word
                                        if (currentWord.endsWith(pattern1) && targetWord.startsWith(pattern2)) {
                                            match = true;
                                        }
                                    }
                                    
                                    if (match) {
                                        // Store the match with original words and positions
                                        matchPairs.push({
                                            first: {
                                                word: textTokens[i],
                                                index: i,
                                                originalWord: textTokens[i],
                                                pattern: pattern1
                                            },
                                            second: {
                                                word: textTokens[targetIndex],
                                                index: targetIndex,
                                                originalWord: textTokens[targetIndex],
                                                pattern: pattern2
                                            },
                                            // Store the sound pattern text
                                            soundPattern: `${pattern1}-${pattern2}`
                                        });
                                        
                                        // Once we find a match in this group, we can skip to the next iteration
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Format operations for Quill
                const formattingOperations = [];
                
                // Helper function to find word positions in text
                function findWordPositionsInText(text, words) {
                    const positions = [];
                    const textLower = text.toLowerCase();
                    
                    for (const word of words) {
                        // Need to handle punctuation and word boundaries
                        const wordRegex = new RegExp(`\\b${escapeRegExp(word.originalWord)}\\b`, 'i');
                        const match = wordRegex.exec(text);
                        
                        if (match) {
                            positions.push({
                                index: match.index,
                                length: match[0].length,
                                word: match[0]
                            });
                        }
                    }
                    
                    return positions;
                }
                
                // Find each matched word in the Quill content and add highlighting
                if (matchPairs.length > 0) {
                    // Get the text content
                    const editorText = quill.getText();
                    
                    // Highlight each matching pair
                    matchPairs.forEach(pair => {
                        // Prepare the words to find positions for
                        const words = [
                            {
                                originalWord: pair.first.originalWord,
                                index: pair.first.index
                            },
                            {
                                originalWord: pair.second.originalWord,
                                index: pair.second.index
                            }
                        ];
                        
                        // Find positions of these words in the text
                        const positions = findWordPositionsInText(editorText, words);
                        
                        // If we found both positions, add formatting operations
                        if (positions.length === 2) {
                            // Add formatting for first word
                            formattingOperations.push({
                                index: positions[0].index,
                                length: positions[0].length,
                                format: { 'background': '#5D5CDE', 'color': 'white' }
                            });
                            
                            // Add formatting for second word
                            formattingOperations.push({
                                index: positions[1].index,
                                length: positions[1].length,
                                format: { 'background': '#5D5CDE', 'color': 'white' }
                            });
                        }
                    });
                    
                    // REMOVED: No longer applying automatic highlighting on analyze
                    // We'll only highlight matches when user clicks on a specific result card
                    // formattingOperations.forEach(op => {
                    //     quill.formatText(op.index, op.length, op.format, 'api');
                    // });
                }
                
                // Create results display
                const resultsList = document.getElementById('homonymResultsList');
                
                if (matchPairs.length > 0) {
                    let listHTML = '';
                    
                    // Group matches by their sound patterns
                    const patternGroups = {};
                    matchPairs.forEach(pair => {
                        if (!patternGroups[pair.soundPattern]) {
                            patternGroups[pair.soundPattern] = [];
                        }
                        patternGroups[pair.soundPattern].push(pair);
                    });
                    
                    // Create sections for each pattern group
                    Object.entries(patternGroups).forEach(([pattern, pairs]) => {
                        listHTML += `
                            <div class="pattern-group mb-4">
                                <h4 class="font-medium mb-2 text-indigo-600 dark:text-indigo-400">Sound Pattern: ${pattern}</h4>
                                <div class="space-y-2">
                        `;
                        
                        // Add each match in this pattern group
                        pairs.forEach((pair, index) => {
                            // Get context around matches
                            const firstIndex = pair.first.index;
                            const secondIndex = pair.second.index;
                            
                            // Generate context for better readability
                            const contextBefore = firstIndex > 0 ? 
                                textTokens.slice(Math.max(0, firstIndex-2), firstIndex).join(' ') : '';
                                
                            const contextBetween = textTokens.slice(firstIndex+1, secondIndex).join(' ');
                            
                            const contextAfter = secondIndex < textTokens.length - 1 ? 
                                textTokens.slice(secondIndex+1, Math.min(textTokens.length, secondIndex+3)).join(' ') : '';
                            
                            // Get the exact words with patterns highlighted
                            const firstWord = pair.first.originalWord;
                            const secondWord = pair.second.originalWord;
                            
                            // Create position signature for click handling
                            const positionSignature = `${firstIndex}:${secondIndex}`;
                            
                            // Create a match result item
                            listHTML += `
                                <div class="match-result p-2 border rounded mb-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" 
                                    data-match-index="${index}" 
                                    data-first-word="${firstIndex}" 
                                    data-second-word="${secondIndex}" 
                                    data-first-text="${firstWord}" 
                                    data-second-text="${secondWord}"
                                    data-position-signature="${positionSignature}">
                                    <div class="truncate">
                                        ${contextBefore ? `...${contextBefore} ` : ''}
                                        <span class="highlight px-1 rounded">${highlightPatternInWord(firstWord, pair.first.pattern, patternLocation === 'startStart' ? 'start' : 'end')}</span> 
                                        ${contextBetween} 
                                        <span class="highlight px-1 rounded">${highlightPatternInWord(secondWord, pair.second.pattern, patternLocation === 'endStart' ? 'start' : 'end')}</span>
                                        ${contextAfter ? ` ${contextAfter}...` : ''}
                                    </div>
                                </div>
                            `;
                        });
                        
                        listHTML += `
                                </div>
                            </div>
                        `;
                    });
                    
                    resultsList.innerHTML = listHTML;
                    
                    // Helper function to find the Nth occurrence of a word in text
                    function findNthWordInText(text, word, n) {
                        const wordRegex = new RegExp(`\\b${escapeRegExp(word)}\\b`, 'g');
                        let count = 0;
                        let match;
                        
                        // Find the nth occurrence
                        while ((match = wordRegex.exec(text)) !== null) {
                            if (count === n) {
                                return match.index;
                            }
                            count++;
                        }
                        
                        // If we couldn't find the exact nth occurrence
                        return -1;
                    }
                    
                    // Add click handler for match results
                    document.querySelectorAll('#homonymResultsList .match-result').forEach(item => {
                        item.addEventListener('click', function() {
                            // If already highlighting a homonym pattern, ignore this click
                            if (isHighlightingHomonymPattern) {
                                return;
                            }
                            
                            // Set flag to prevent multiple clicks
                            isHighlightingHomonymPattern = true;
                            
                            // Disable the editor to prevent clicks during highlighting
                            const editor = document.querySelector('.ql-editor');
                            if (editor) {
                                editor.style.pointerEvents = 'none';
                            }
                            
                            // Show countdown timer in the tab header - use 'homonym' type
                            showCountdownTimer(4, 'homonym');
                            
                            // First clear any existing highlights
                            if (userFormattedContents) {
                                quill.setContents(userFormattedContents);
                            }
                            
                            // Get data from the match card - decode HTML entities to handle quotes properly
                            const decodedFirstWord = this.dataset.firstText.replace(/&quot;/g, '"').replace(/&amp;/g, '&');
                            const decodedSecondWord = this.dataset.secondText.replace(/&quot;/g, '"').replace(/&amp;/g, '&');
                            
                            // Get position signature
                            const positionSignature = this.dataset.positionSignature;
                            const [firstWordIndex, secondWordIndex] = positionSignature.split(':').map(Number);
                            
                            // Get current text from Quill
                            const currentText = quill.getText();
                            
                            // Show countdown timer in the tab header
                            showCountdownTimer(4);
                            
                            // Try to find the words in the current text using the more robust method
                            // that's also used in the Letter Patterns tab
                            const firstWordPosition = findWordInText(currentText, decodedFirstWord, firstWordIndex);
                            const secondWordPosition = findWordInText(currentText, decodedSecondWord, secondWordIndex);
                            
                            // If we found either word, highlight both words and scroll to the first one
                            if (firstWordPosition !== -1 && secondWordPosition !== -1) {
                                // Highlight both words - use decodedFirstWord.length for proper length
                                quill.formatText(firstWordPosition, decodedFirstWord.length, {
                                    'background': '#5D5CDE',
                                    'color': 'white'
                                }, 'api');
                                
                                quill.formatText(secondWordPosition, decodedSecondWord.length, {
                                    'background': '#5D5CDE',
                                    'color': 'white'
                                }, 'api');
                                
                                // Set selection to the first word
                                quill.setSelection(firstWordPosition, decodedFirstWord.length);
                                quill.focus();
                            } else if (firstWordPosition !== -1) {
                                // Only first word found
                                quill.formatText(firstWordPosition, decodedFirstWord.length, {
                                    'background': '#5D5CDE',
                                    'color': 'white'
                                }, 'api');
                                
                                quill.setSelection(firstWordPosition, decodedFirstWord.length);
                                quill.focus();
                            } else if (secondWordPosition !== -1) {
                                // Only second word found
                                quill.formatText(secondWordPosition, decodedSecondWord.length, {
                                    'background': '#5D5CDE',
                                    'color': 'white'
                                }, 'api');
                                
                                quill.setSelection(secondWordPosition, decodedSecondWord.length);
                                quill.focus();
                            }
                            
                            // Ensure the Quill editor container scrolls to show the selection
                            const editorContainer = document.querySelector('.ql-editor');
                            if (editorContainer) {
                                const scrollPosition = firstWordPosition !== -1 ? firstWordPosition : secondWordPosition;
                                
                                if (scrollPosition !== -1) {
                                    // Find the relative position of the match within the editor
                                    const totalText = quill.getText();
                                    const percentPosition = scrollPosition / totalText.length;
                                    
                                    // Calculate scroll position within the editor container
                                    const scrollTarget = percentPosition * editorContainer.scrollHeight;
                                    
                                    // Scroll with a small offset to ensure visibility
                                    editorContainer.scrollTop = Math.max(0, scrollTarget - 50);
                                }
                            }
                            
                            // ALWAYS scroll the window to ensure the editor is in view
                            const editorArea = document.querySelector('.text-editor');
                            if (editorArea) {
                                // Get the position of the editor element relative to the viewport
                                const editorRect = editorArea.getBoundingClientRect();
                                
                                // Calculate how much to scroll to position the editor properly
                                const scrollBy = editorRect.top - 20; // Position with 20px padding from top
                                
                                // Smooth scroll to the editor
                                window.scrollBy({
                                    top: scrollBy,
                                    behavior: 'smooth'
                                });
                            }
                            
                            // Automatically clear the highlight after 3 seconds
                            setTimeout(() => {
                                // Restore original formatting
                                if (userFormattedContents) {
                                    quill.setContents(userFormattedContents);
                                }
                                
                                // Release the highlighting lock and re-enable the editor after the 
                                // highlighting is completely done
                                setTimeout(() => {
                                    isHighlightingHomonymPattern = false;
                                    // Re-enable the editor
                                    if (editor) {
                                        editor.style.pointerEvents = 'auto';
                                    }
                                }, 500);
                            }, 3000);
                        });
                    });
                } else {
                    resultsList.innerHTML = '<div class="text-center text-gray-500 italic">No matches found. Try adjusting your settings or pattern groups.</div>';
                }
            }
            
            // Helper function to highlight pattern within a word
            function highlightPatternInWord(word, pattern, position) {
                if (position === 'start') {
                    if (word.toLowerCase().startsWith(pattern.toLowerCase())) {
                        return `<span class="letter-highlight">${word.substring(0, pattern.length)}</span>${word.substring(pattern.length)}`;
                    }
                } else { // end
                    if (word.toLowerCase().endsWith(pattern.toLowerCase())) {
                        return `${word.substring(0, word.length - pattern.length)}<span class="letter-highlight">${word.substring(word.length - pattern.length)}</span>`;
                    }
                }
                return word;
            }
            
            // Variables to track analysis states
            let hasAnalyzedHomonyms = false;
            let configurationChanged = false;
            let currentPronounText = '';
            let currentAnalyzedText = '';
            let currentWordCounts = {};
            let sentences = []; // For storing sentence analysis
            let originalTextContent = ''; // Store the original text for rhythm tab
            
            // Function to analyze text based on selected tab
            function analyzeText(tabId) {
                // Save current editor contents to preserve formatting
                saveEditorContents();
                
                const text = getEditableText();
                if (!text) {
                    alert('Please enter some text to analyze.');
                    return;
                }
                
                if (tabId === 'homophonesTab') {
                    analyzeHomonyms();
                } else if (tabId === 'pronounsTab') {
                    analyzePronouns(text);
                } else if (tabId === 'densityTab') {
                    analyzeDensity(text);
                } else if (tabId === 'customSetsTab') {
                    analyzeCustomSets(text);
                } else if (tabId === 'rhythmTab') {
                    analyzeRhythm();
                } else if (tabId === 'homonymPatternsTab') {
                    analyzeHomonymPatterns();
                }
                
                // Restore editor contents after analysis to preserve formatting
                restoreEditorContents();
            }
            
            //======================================
            // RHYTHM TAB FUNCTIONALITY
            //======================================
            
            // Function to analyze sentence rhythms
            function analyzeRhythm() {
                // Save current formatting
                saveEditorContents();
                
                // Always refresh the original text content when analyzing
                // This ensures that edits made in other tabs are captured
                originalTextContent = getEditableText();
                
                if (!originalTextContent) {
                    alert('Please enter some text to analyze.');
                    return;
                }
                
                // Check if text is primarily Chinese or Japanese
                const isCJKText = isChineseOrJapanese(originalTextContent);
                
                // Show/hide CJK indicator
                const cjkIndicator = document.getElementById('cjk-indicator');
                if (isCJKText) {
                    // Check if browser supports Intl.Segmenter
                    if (typeof Intl !== 'undefined' && Intl.Segmenter) {
                        cjkIndicator.classList.remove('hidden');
                    } else {
                        // Modify the indicator message if Intl.Segmenter is not available
                        cjkIndicator.querySelector('span').textContent = 
                            'CJK (Chinese/Japanese/Korean) text detected. Using character-based counting (your browser doesn\'t support Intl.Segmenter).';
                        cjkIndicator.classList.remove('hidden');
                    }
                } else {
                    cjkIndicator.classList.add('hidden');
                }
                
                // Parse the text into sentences
                sentences = parseSentences(originalTextContent);
                
                if (sentences.length === 0) {
                    document.getElementById('sentence-chart').innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400 italic py-16 w-full">No sentences found in the text</div>';
                    return;
                }
                
                // Clear previous chart
                document.getElementById('sentence-chart').innerHTML = '';
                
                // Determine the maximum word count for scaling
                const maxWordCount = Math.max(
                    ...sentences.map(s => s.type === 'sentence' ? countWords(s.text) : 0),
                    21 // Minimum height for extra-long category
                );
                
                // Determine a reasonable maximum height for bars to ensure tooltips are visible
                // Using a lower max height for extra-long sentence bars
                const maxBarHeight = 120; // Reduced from 150px
                
                // Create visualization with a single bar chart
                renderSentenceBars(sentences, maxWordCount, maxBarHeight);
                
                // Adjust container width based on number of sentences
                adjustRhythmContainerWidth(sentences.length);
                
                // Add sentence distribution summary
                addSentenceDistributionSummary(sentences);
                
                // Restore editor contents
                restoreEditorContents();
            }
            
            // Function to add sentence distribution summary (now on a fixed container)
            function addSentenceDistributionSummary(sentences) {
                // Filter out paragraph breaks to just get sentence data
                const sentencesOnly = sentences.filter(s => s.type === 'sentence');
                
                if (sentencesOnly.length === 0) {
                    return;
                }
                
                // Calculate sentence types
                const shortSentences = sentencesOnly.filter(s => countWords(s.text) <= 5);
                const mediumSentences = sentencesOnly.filter(s => {
                    const wordCount = countWords(s.text);
                    return wordCount > 5 && wordCount <= 10;
                });
                const longSentences = sentencesOnly.filter(s => {
                    const wordCount = countWords(s.text);
                    return wordCount > 10 && wordCount <= 20;
                });
                const extraLongSentences = sentencesOnly.filter(s => countWords(s.text) > 20);
                
                // Calculate percentages
                const total = sentencesOnly.length;
                const shortPercentage = ((shortSentences.length / total) * 100).toFixed(1);
                const mediumPercentage = ((mediumSentences.length / total) * 100).toFixed(1);
                const longPercentage = ((longSentences.length / total) * 100).toFixed(1);
                const extraLongPercentage = ((extraLongSentences.length / total) * 100).toFixed(1);
                
                // Calculate average words per sentence
                const totalWords = sentencesOnly.reduce((sum, sentence) => sum + countWords(sentence.text), 0);
                const averageWords = (totalWords / total).toFixed(1);
                
                // Create summary container - updated colors to match rhythm legend
                const summaryHtml = `
                    <h4 class="font-medium mb-4">Sentence Distribution</h4>
                    <div class="flex justify-center mb-6 px-2">
                        <div class="w-full h-10 flex rounded-lg overflow-hidden">
                            <div class="h-full flex flex-col items-start justify-center px-2" style="background-color: var(--short-color); width: ${shortPercentage === '0.0' ? '5%' : shortPercentage + '%'}; color: #000000 !important;">
                                <span class="font-medium text-xs">${shortSentences.length}</span>
                                <span class="text-xs"><span class="text-[0.65rem]">${shortPercentage}%</span></span>
                            </div>
                            <div class="h-full flex flex-col items-start justify-center px-2" style="background-color: var(--medium-color); width: ${mediumPercentage === '0.0' ? '5%' : mediumPercentage + '%'}; color: #000000 !important;">
                                <span class="font-medium text-xs">${mediumSentences.length}</span>
                                <span class="text-xs"><span class="text-[0.65rem]">${mediumPercentage}%</span></span>
                            </div>
                            <div class="h-full flex flex-col items-start justify-center px-2" style="background-color: var(--long-color); width: ${longPercentage === '0.0' ? '5%' : longPercentage + '%'}; color: #000000 !important;">
                                <span class="font-medium text-xs">${longSentences.length}</span>
                                <span class="text-xs"><span class="text-[0.65rem]">${longPercentage}%</span></span>
                            </div>
                            <div class="h-full flex flex-col items-start justify-center px-2" style="background-color: var(--extra-long-color); width: ${extraLongPercentage === '0.0' ? '5%' : extraLongPercentage + '%'}; color: #000000 !important;">
                                <span class="font-medium text-xs">${extraLongSentences.length}</span>
                                <span class="text-xs"><span class="text-[0.65rem]">${extraLongPercentage}%</span></span>
                            </div>
                        </div>
                    </div>
                    <div class="border-t pt-3 dark:border-gray-700">
                        <div class="font-medium">Average words per sentence: ${averageWords}</div>
                    </div>
                `;
                
                // Get the distribution container (which is separate from the chart container)
                const distributionContainer = document.getElementById('distribution-container');
                
                // Update the distribution container with the summary
                distributionContainer.innerHTML = summaryHtml;
                
                // Show the container if it was previously hidden
                distributionContainer.classList.remove('hidden');
            }
            
            // Parse text into a hierarchical structure of paragraphs and sentences
            // Improved approach for correct handling of duplicate sentences
            function parseSentences(text) {
                // Create the basic structure for visualization
                const sentencesWithBreaks = [];
                
                // Create a hierarchical structure with paragraphs and sentences
                const documentStructure = {
                    paragraphs: [],
                    sentenceMap: {} // Maps sentence indices in flat array to paragraph/sentence indices
                };
                
                // Split the text by line breaks
                const paragraphs = text.split('\n');
                let globalSentenceIndex = 0;
                
                // Track sentence occurrences in each paragraph
                const sentenceOccurrenceMap = new Map();
                
                // Process each paragraph
                paragraphs.forEach((paragraph, paragraphIndex) => {
                    // Add paragraph to our structure (even if empty)
                    documentStructure.paragraphs[paragraphIndex] = {
                        text: paragraph,
                        sentences: [],
                        isEmpty: !paragraph.trim()
                    };
                    
                    // Add a paragraph break for any paragraph except the first
                    if (paragraphIndex > 0) {
                        sentencesWithBreaks.push({
                            text: '\n',
                            type: 'paragraph-break',
                            paragraphIndex: paragraphIndex,
                            isEmpty: !paragraph.trim()
                        });
                    }
                    
                    // If it's an empty paragraph, we're done with this one
                    if (!paragraph.trim()) {
                        return;
                    }
                    
                    // Reset the sentence occurrence tracking for this paragraph
                    sentenceOccurrenceMap.clear();
                    
                    // Handle quotes and terminal punctuation - simplified approach
                    let processedParagraph = paragraph;
                    
                    // Step 1: Split into sentences, carefully considering terminal punctuation and quotes
                    let sentences = [];
                    let currentSentence = "";
                    let inQuotes = false;
                    let quoteChar = null;
                    
                    // Determine if this paragraph contains significant CJK characters
                    const isCJKParagraph = isChineseOrJapanese(processedParagraph);
                    
                    // Define terminal punctuation including CJK punctuation
                    // Western: . ! ?
                    // CJK: 。 ！ ？ ～
                    const terminalPunctuation = ['.', '!', '?', '。', '！', '？', '～'];
                    
                    // Helper function to check if a single quote is likely an apostrophe in a contraction or name
                    function isLikelyApostrophe(text, position) {
                        // Check if this appears to be a contraction, possessive, or name with apostrophe
                        const prevChar = position > 0 ? text.charAt(position - 1) : '';
                        const nextChar = position < text.length - 1 ? text.charAt(position + 1) : '';
                        
                        // If apostrophe is in the middle of letters (like O'Neal, D'Arcy), it's part of a name
                        if (/[a-zA-Z]/.test(prevChar) && /[a-zA-Z]/.test(nextChar)) {
                            return true;
                        }
                        
                        // Common English contractions and possessives
                        if (/[a-zA-Z]/.test(prevChar)) {
                            // Contractions like "it's", "don't", "won't", "couldn't", etc.
                            if (nextChar === 's' || nextChar === 't' || nextChar === 'v' || 
                                nextChar === 'l' || nextChar === 'r' || nextChar === 'm' || nextChar === 'd') {
                                return true;
                            }
                            
                            // Possessives with 's at end of word
                            if (nextChar === 's' && position < text.length - 2) {
                                const afterS = text.charAt(position + 2);
                                if (/[\s.,!?;:]/.test(afterS) || !afterS) {
                                    return true;
                                }
                            }
                        }
                        
                        return false;
                    }
                    
                    // Track bracket and parenthesis state
                    let inBrackets = false;
                    let bracketChar = null;
                    const bracketPairs = { '[': ']', '(': ')', '{': '}' };
                    
                    for (let i = 0; i < processedParagraph.length; i++) {
                        const char = processedParagraph[i];
                        currentSentence += char;
                        
                        // Track bracket state
                        if (['[', '(', '{'].includes(char)) {
                            inBrackets = true;
                            bracketChar = char;
                        } else if (inBrackets && 
                                  ((bracketChar === '[' && char === ']') ||
                                   (bracketChar === '(' && char === ')') ||
                                   (bracketChar === '{' && char === '}'))) {
                            inBrackets = false;
                            bracketChar = null;
                        }
                        
                        // Check for quotes - distinguish apostrophes from quotation marks
                        if ((char === '"' || char === '"' || char === '"' || char === '「' || char === '」') || 
                            (char === "'" && !isLikelyApostrophe(processedParagraph, i))) {
                            
                            if (!inQuotes) {
                                inQuotes = true;
                                quoteChar = char;
                                // Map opening quotes to closing quotes
                                if (char === '"') quoteChar = '"';
                                if (char === '「') quoteChar = '」';
                            } else if ((char === quoteChar) || 
                                      (quoteChar === '"' && char === '"') || 
                                      (quoteChar === '「' && char === '」')) {
                                inQuotes = false;
                                quoteChar = null;
                            }
                        }
                        
                        // Safety check: if we reach the end of the paragraph and still in quotes/brackets,
                        // we need to force-close them to prevent the entire paragraph being treated as one sentence
                        if (i === processedParagraph.length - 1) {
                            inQuotes = false;
                            quoteChar = null;
                            inBrackets = false;
                            bracketChar = null;
                        }
                        
                        // Check for sentence endings (terminal punctuation)
                        // IMPORTANT: We now respect sentence breaks even inside brackets
                        if (!inQuotes && terminalPunctuation.includes(char)) {
                            // For Western text, we need a space, quote, or end after punctuation
                            // For CJK text, terminal punctuation is always a sentence end
                            if (isCJKParagraph || 
                                i === processedParagraph.length - 1 || 
                                /\s/.test(processedParagraph[i+1]) ||
                                ['"', "'", '"', '"', '」', ']', ')', '}'].includes(processedParagraph[i+1])) {
                                
                                // Handle remaining quotes or brackets after the punctuation
                                let endIndex = i + 1;
                                while (endIndex < processedParagraph.length && 
                                      (processedParagraph[endIndex] === '"' || 
                                       processedParagraph[endIndex] === "'" || 
                                       processedParagraph[endIndex] === '"' ||
                                       processedParagraph[endIndex] === '"' ||
                                       processedParagraph[endIndex] === '」' ||
                                       processedParagraph[endIndex] === ')' || 
                                       processedParagraph[endIndex] === ']' || 
                                       processedParagraph[endIndex] === '}')) {
                                    currentSentence += processedParagraph[endIndex];
                                    endIndex++;
                                }
                                
                                // Skip past the end characters we've added
                                i = endIndex - 1;
                                
                                if (currentSentence.trim()) {
                                    sentences.push(currentSentence);
                                }
                                currentSentence = "";
                            }
                        }
                    }
                    
                    // Add any remaining text as a sentence if it's not empty
                    if (currentSentence.trim()) {
                        sentences.push(currentSentence);
                    }
                    
                    // If no sentences were detected but paragraph has content, treat as one sentence
                    if (sentences.length === 0 && paragraph.trim()) {
                        sentences.push(paragraph);
                    }
                    
                    // Add sentences to our structure
                    sentences.forEach((sentenceText, idxInParagraph) => {
                        if (sentenceText.trim()) {
                            // Track identical sentences within the same paragraph
                            // This is crucial for highlighting the correct sentence when duplicates exist
                            let occurrenceIndex = 0;
                            if (sentenceOccurrenceMap.has(sentenceText)) {
                                occurrenceIndex = sentenceOccurrenceMap.get(sentenceText) + 1;
                            }
                            sentenceOccurrenceMap.set(sentenceText, occurrenceIndex);
                            
                            // Add to our flat array for visualization
                            sentencesWithBreaks.push({
                                text: sentenceText,
                                type: 'sentence',
                                paragraphIndex: paragraphIndex,
                                sentenceIndex: idxInParagraph,
                                occurrenceIndex: occurrenceIndex, // Track which occurrence this is for identical sentences
                                fullText: sentenceText
                            });
                            
                            // Add to the hierarchical structure
                            documentStructure.paragraphs[paragraphIndex].sentences.push({
                                text: sentenceText,
                                index: idxInParagraph,
                                occurrenceIndex: occurrenceIndex
                            });
                            
                            // Map the flat index to paragraph/sentence indices
                            documentStructure.sentenceMap[globalSentenceIndex] = {
                                paragraphIndex: paragraphIndex,
                                sentenceIndex: idxInParagraph,
                                occurrenceIndex: occurrenceIndex
                            };
                            
                            globalSentenceIndex++;
                        }
                    });
                });
                
                // Store the document structure for later use
                window.documentStructure = documentStructure;
                
                return sentencesWithBreaks;
            }
            
            // Get just the sentences (no paragraph breaks) for highlighting purposes
            function getSentencesOnly(sentences) {
                return sentences.filter(s => s.type === 'sentence');
            }
            
            // Detect if text is primarily Chinese or Japanese or Korean
            function isChineseOrJapanese(text) {
                if (!text) return false;
                // Check if text contains a significant number of CJK characters
                // Unicode ranges:
                // Chinese: \u4e00-\u9fff (CJK Unified Ideographs)
                // Japanese: \u3040-\u309f (Hiragana), \u30a0-\u30ff (Katakana), \u3400-\u4dbf (CJK Extension A)
                // Korean: \uac00-\ud7af (Hangul Syllables)
                // Shared: \u3000-\u303f (CJK Symbols & Punctuation), \uff00-\uffef (Halfwidth and Fullwidth Forms)
                const cjkPattern = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff00-\uffef\uac00-\ud7af]/g;
                const matches = text.match(cjkPattern) || [];
                // If more than 40% of characters are CJK, consider it Chinese/Japanese/Korean
                return matches.length > 0 && (matches.length / text.length) > 0.4;
            }

            // Count words in a sentence with CJK support
            function countWords(sentence) {
                if (isChineseOrJapanese(sentence)) {
                    try {
                        // Use Intl.Segmenter for Chinese/Japanese when available
                        if (typeof Intl !== 'undefined' && Intl.Segmenter) {
                            const segmenter = new Intl.Segmenter(['ja', 'zh'], { granularity: 'word' });
                            const segments = segmenter.segment(sentence);
                            // Count only word segments (not punctuation/whitespace)
                            return Array.from(segments)
                                .filter(segment => segment.isWordLike)
                                .length;
                        }
                    } catch (e) {
                        console.error("Error using Intl.Segmenter:", e);
                        // Fallback: rough approximation for CJK languages - count each character as a word
                        return sentence.replace(/\s+/g, '').length;
                    }
                }
                
                // Default for non-CJK languages: split by whitespace
                return sentence.split(/\s+/).filter(word => word.length > 0).length;
            }
            
            // FIXED: Render bars for sentence visualization - using different variable names
            function renderSentenceBars(sentences, maxWordCount) {
                const container = document.getElementById('sentence-chart');
                
                if (sentences.length === 0) {
                    container.innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400 italic py-16 w-full">No sentences found in the text</div>';
                    return;
                }
                
                // Calculate a reasonable max word count to prevent extreme scaling
                const reasonableMaxWordCount = calculateReasonableMaxWordCount(sentences, maxWordCount);
                
                // Create a bar for each sentence in order
                sentences.forEach((sentence, index) => {
                    const bar = document.createElement('div');
                    let barClass = 'rhythm-bar';
                    
                    if (sentence.type === 'paragraph-break') {
                        barClass += ' rhythm-bar-paragraph';
                        bar.title = 'Paragraph break';
                    } else {
                        // Get sentence word count
                        const sentenceWordCount = countWords(sentence.text);
                        
                        // Determine sentence category
                        if (sentenceWordCount <= 5) {
                            barClass += ' rhythm-bar-short';
                        } else if (sentenceWordCount <= 10) {
                            barClass += ' rhythm-bar-medium';
                        } else if (sentenceWordCount <= 20) {
                            barClass += ' rhythm-bar-long';
                        } else {
                            barClass += ' rhythm-bar-extralong';
                        }
                        
                        // Get min/max heights from CSS classes for this category
                        let minHeight, maxHeight;
                        if (barClass.includes('rhythm-bar-short')) {
                            minHeight = 15;
                            maxHeight = 40;
                        } else if (barClass.includes('rhythm-bar-medium')) {
                            minHeight = 45;
                            maxHeight = 70;
                        } else if (barClass.includes('rhythm-bar-long')) {
                            minHeight = 75;
                            maxHeight = 100;
                        } else { // extralong
                            minHeight = 105;
                            maxHeight = 125;
                        }
                        
                        // Use capped word count for scaling to prevent one extremely long sentence
                        // from making all others tiny - use reasonableMaxWordCount instead of absolute max
                        const scalingWordCount = Math.min(sentenceWordCount, reasonableMaxWordCount);
                        
                        // Calculate height proportionally within the category's min/max range
                        let heightPx;
                        if (sentenceWordCount <= 20) {
                            // For normal sentences, calculate height within their category's range
                            const categoryMax = sentenceWordCount <= 5 ? 5 : sentenceWordCount <= 10 ? 10 : 20;
                            const categoryMin = sentenceWordCount <= 5 ? 1 : sentenceWordCount <= 10 ? 6 : 11;
                            const rangeFactor = (sentenceWordCount - categoryMin) / (categoryMax - categoryMin);
                            heightPx = minHeight + (rangeFactor * (maxHeight - minHeight));
                        } else {
                            // For extra-long sentences, scale within the extra-long range
                            const rangeFactor = Math.min(1, (scalingWordCount - 21) / (reasonableMaxWordCount - 21));
                            heightPx = minHeight + (rangeFactor * (maxHeight - minHeight));
                        }
                        
                        // Ensure height stays within bounds
                        heightPx = Math.max(minHeight, Math.min(maxHeight, heightPx));
                        
                        // Apply the calculated height
                        bar.style.height = `${heightPx}px`;
                        
                        // Add overflow indicator for sentences that are extremely long
                        if (sentenceWordCount > reasonableMaxWordCount && barClass.includes('rhythm-bar-extralong')) {
                            // Add overflow indicator with white stripes
                            const indicator = document.createElement('div');
                            indicator.className = 'rhythm-overflow-indicator';
                            
                            // Add three stripes
                            for (let i = 0; i < 3; i++) {
                                const stripe = document.createElement('div');
                                stripe.className = 'rhythm-overflow-stripe';
                                indicator.appendChild(stripe);
                            }
                            
                            bar.appendChild(indicator);
                            
                            // Update the title to show it's exceptionally long
                            const ratio = Math.round((sentenceWordCount / reasonableMaxWordCount) * 10) / 10;
                            bar.title = `${sentenceWordCount} words (${ratio}x longer than typical)`;
                        }
                        
                        // Create tooltip with word count
                        const truncatedText = sentence.text.length > 25 
                            ? sentence.text.substring(0, 25) + '...' 
                            : sentence.text;
                        
                        // Add word count to tooltip text
                        let tooltipText = `${sentenceWordCount} words - ${truncatedText}`;
                        if (sentenceWordCount > reasonableMaxWordCount) {
                            const ratio = Math.round((sentenceWordCount / reasonableMaxWordCount) * 10) / 10;
                            tooltipText = `${sentenceWordCount} words (${ratio}x longer) - ${truncatedText}`;
                        }
                        
                        const tooltip = document.createElement('div');
                        tooltip.className = 'rhythm-tooltip';
                        tooltip.textContent = tooltipText;
                        bar.appendChild(tooltip);
                    }
                    
                    bar.className = barClass;
                    
                    // Store sentence index for click handling
                    bar.dataset.sentenceIndex = index;
                    
                    // Add click event to highlight the sentence
                    bar.addEventListener('click', function() {
                        highlightSentence(parseInt(this.dataset.sentenceIndex));
                    });
                    
                    container.appendChild(bar);
                });
            }
            
            // Helper function to calculate a reasonable max word count for scaling
            function calculateReasonableMaxWordCount(sentences, absoluteMaxWordCount) {
                // Filter to get only sentences (no paragraph breaks)
                const sentencesOnly = sentences.filter(s => s.type === 'sentence');
                
                if (sentencesOnly.length === 0) return 30; // Default reasonable max
                
                // Calculate word counts for all sentences
                const wordCounts = sentencesOnly.map(s => countWords(s.text));
                
                // For very small samples, use a simpler approach
                if (sentencesOnly.length < 5) {
                    return Math.max(30, Math.min(absoluteMaxWordCount, 2 * Math.max(...wordCounts.filter(c => c <= 50))));
                }
                
                // Calculate median word count (more robust than average)
                const sortedCounts = [...wordCounts].sort((a, b) => a - b);
                const medianIndex = Math.floor(sortedCounts.length / 2);
                const medianCount = sortedCounts[medianIndex];
                
                // Get counts without extreme outliers (>3x median)
                const nonOutlierCounts = wordCounts.filter(count => count <= medianCount * 3);
                const nonOutlierMax = nonOutlierCounts.length > 0 ? Math.max(...nonOutlierCounts) : medianCount * 2;
                
                // Use the highest of:
                // 1. The max non-outlier count
                // 2. 2x the median count
                // 3. Minimum of 30 words (for visual consistency)
                // But cap at 80 words as a reasonable upper limit
                return Math.min(
                    80,
                    Math.max(
                        nonOutlierMax,
                        Math.max(medianCount * 2, 30)
                    )
                );
            }
            
            // Flags to track highlighting states across tabs
            let isHighlightingSentence = false; // For Rhythm tab
            let isHighlightingLetterPattern = false; // For Letter Patterns tab
            let isHighlightingHomonymPattern = false; // For Homonym Patterns tab
            
            // Enhanced paragraph-aware sentence highlighting with improved duplicate sentence handling
            function highlightSentence(sentenceIndex) {
                // Save current editor contents
                saveEditorContents();
                
                // If already highlighting, ignore this click
                if (isHighlightingSentence) {
                    return;
                }
                
                // Set flag to prevent multiple clicks
                isHighlightingSentence = true;
                
                // Disable the editor to prevent clicks during highlighting
                const editor = document.querySelector('.ql-editor');
                if (editor) {
                    editor.style.pointerEvents = 'none';
                }
                
                try {
                    // Get the current text content from the editable area
                    // This ensures we work with the most recent user edits
                    const currentTextContent = getEditableText();
                    
                    // Update originalTextContent with the current text
                    originalTextContent = currentTextContent;
                    
                    // Get the sentence data
                    const sentence = sentences[sentenceIndex];
                    
                    // If it's a paragraph break, just exit
                    if (sentence.type === 'paragraph-break') {
                        // Release the lock after a small delay
                        setTimeout(() => {
                            isHighlightingSentence = false;
                        }, 500);
                        return;
                    }
                    
                    // Access the document structure we built during parsing
                    const docStructure = window.documentStructure;
                    if (!docStructure) {
                        console.error("Document structure not found");
                        isHighlightingSentence = false;
                        return;
                    }
                    
                    // Get the paragraph and sentence index information
                    const paragraphIndex = sentence.paragraphIndex;
                    const sentenceIndexInParagraph = sentence.sentenceIndex;
                    const occurrenceIndex = sentence.occurrenceIndex || 0;
                    
                    console.log(`Highlighting sentence: Paragraph ${paragraphIndex}, Sentence ${sentenceIndexInParagraph}, Occurrence ${occurrenceIndex}`);
                    
                    // Determine sentence category for matching highlight color
                    const wordCount = countWords(sentence.text);
                    let highlightClass = 'highlight-sentence';
                    
                    if (wordCount <= 5) {
                        highlightClass = 'highlight-sentence-short';
                    } else if (wordCount <= 10) {
                        highlightClass = 'highlight-sentence-medium';
                    } else if (wordCount <= 20) {
                        highlightClass = 'highlight-sentence-long';
                    } else {
                        highlightClass = 'highlight-sentence-extralong';
                    }
                    
                    // Get the Quill editor content - use clean text without formatting
                    const editorText = quill.getText();
                    
                    // COMPLETELY REVAMPED DUPLICATE SENTENCE HANDLING
                    // Using paragraph structure to find the exact sentence occurrence
                    
                    // Build a map of sentence indices within each paragraph
                    // This helps us find the correct occurrence of duplicate sentences
                    let targetPosition = -1;
                    
                    // First, extract all text by paragraph with indices
                    const paragraphMap = [];
                    let currentPosition = 0;
                    
                    // Get all paragraph texts with their start positions
                    // Improved handling for multiple consecutive line breaks
                    let i = 0;
                    let text = editorText;
                    let startPos = 0;
                    
                    while (i < docStructure.paragraphs.length) {
                        const paragraph = docStructure.paragraphs[i];
                        
                        // Handle empty paragraphs (just line breaks) more carefully
                        if (paragraph.isEmpty) {
                            // For empty paragraphs, we just need to find the line break
                            const nextNonEmptyIndex = findNextNonEmptyParagraphIndex(i, docStructure.paragraphs);
                            
                            // If there are multiple consecutive empty paragraphs, handle them as a group
                            if (nextNonEmptyIndex > i + 1) {
                                const emptyCount = nextNonEmptyIndex - i;
                                
                                // Add all empty paragraphs as a group
                                paragraphMap.push({
                                    index: i,
                                    startPos: currentPosition,
                                    text: "\n".repeat(emptyCount - 1), // Multiple line breaks
                                    isEmpty: true,
                                    isEmptyGroup: true,
                                    emptyCount: emptyCount
                                });
                                
                                // Advance the current position by the number of line breaks
                                currentPosition += emptyCount - 1;
                                
                                // Skip to the next non-empty paragraph
                                i = nextNonEmptyIndex - 1; // -1 because the loop will increment i
                            } else {
                                // Single empty paragraph
                                paragraphMap.push({
                                    index: i,
                                    startPos: currentPosition,
                                    text: "",
                                    isEmpty: true
                                });
                            }
                        } else {
                            // Regular paragraph with content
                            paragraphMap.push({
                                index: i,
                                startPos: currentPosition,
                                text: paragraph.text,
                                isEmpty: false
                            });
                            
                            // Move position counter forward (include the paragraph text length)
                            currentPosition += paragraph.text.length;
                        }
                        
                        // Always add a newline character after each paragraph (empty or not)
                        currentPosition += 1;
                        i++;
                    }
                    
                    // Now find our target paragraph
                    const targetParagraph = paragraphMap.find(p => p.index === paragraphIndex);
                    if (!targetParagraph) {
                        console.error("Target paragraph not found in paragraph map");
                        isHighlightingSentence = false;
                        return;
                    }
                    
                    // Get the exact sentence text we need to find
                    const sentenceText = sentence.text;
                    const escapedSentenceText = escapeRegExp(sentenceText);
                    
                    // Find all occurrences of this sentence text within the target paragraph
                    const sentenceRegex = new RegExp(escapedSentenceText, 'g');
                    let sentenceMatch;
                    const paragraphSentences = [];
                    let paragraphSubstr = editorText.substring(targetParagraph.startPos);
                    
                    // Reset regex
                    sentenceRegex.lastIndex = 0;
                    
                    // Find all occurrences in this paragraph
                    while ((sentenceMatch = sentenceRegex.exec(paragraphSubstr)) !== null) {
                        paragraphSentences.push({
                            text: sentenceMatch[0],
                            paragraphOffset: sentenceMatch.index,
                            globalPosition: targetParagraph.startPos + sentenceMatch.index
                        });
                    }
                    
                    // No matches found in the target paragraph
                    if (paragraphSentences.length === 0) {
                        console.error("Sentence not found in target paragraph");
                        isHighlightingSentence = false;
                        return;
                    }
                    
                    // Find the correct occurrence within this paragraph
                    if (occurrenceIndex < paragraphSentences.length) {
                        // We found the exact occurrence
                        targetPosition = paragraphSentences[occurrenceIndex].globalPosition;
                    } else {
                        // Fallback: use the last occurrence in this paragraph
                        targetPosition = paragraphSentences[paragraphSentences.length - 1].globalPosition;
                    }
                    
                    console.log(`Found target sentence at position ${targetPosition} (occurrence ${occurrenceIndex} in paragraph ${paragraphIndex})`);
                    
                    // Store existing formatting before making changes
                    const originalContents = quill.getContents();
                    
                    // Add background color to highlight the sentence
                    quill.formatText(
                        targetPosition,
                        sentenceText.length,
                        'background',
                        getMatchingHighlightColor(highlightClass)
                    );
                    
                    // VASTLY IMPROVED SCROLLING LOGIC:
                    
                    // First, make sure the Quill editor is in view in the window
                    const editorArea = document.querySelector('.text-editor');
                    if (editorArea) {
                        // Get the position of the editor element relative to the viewport
                        const editorRect = editorArea.getBoundingClientRect();
                        
                        // If the editor is not fully visible, scroll to it first
                        if (editorRect.top < 0 || editorRect.bottom > window.innerHeight) {
                            window.scrollTo({
                                top: window.scrollY + editorRect.top - 20, // Position with padding
                                behavior: 'smooth'
                            });
                            
                            // Wait a bit for the window scroll to complete before scrolling inside the editor
                            setTimeout(() => {
                                scrollToHighlightedSentence(targetPosition, sentenceText.length);
                            }, 100);
                        } else {
                            // Editor is already visible, just scroll to the sentence
                            scrollToHighlightedSentence(targetPosition, sentenceText.length);
                        }
                    }
                    
                    // Show countdown timer in the tab header
                    showCountdownTimer(4);
                    
                    // Remove highlight after animation completes (2.5 seconds)
                    setTimeout(() => {
                        // Restore original formatting
                        quill.setContents(originalContents);
                        
                        // Release the highlighting lock and re-enable the editor 
                        // Both after animation is completely done
                        setTimeout(() => {
                            isHighlightingSentence = false;
                            // Re-enable the editor
                            if (editor) {
                                editor.style.pointerEvents = 'auto';
                            }
                        }, 500);
                    }, 2500);
                } catch (error) {
                    console.error("Error highlighting sentence:", error);
                    // Ensure we always release the lock even if there's an error
                    isHighlightingSentence = false;
                    // Restore editor contents
                    restoreEditorContents();
                }
            }
            
            // Helper function to find the next non-empty paragraph index
            function findNextNonEmptyParagraphIndex(startIndex, paragraphs) {
                for (let i = startIndex + 1; i < paragraphs.length; i++) {
                    if (!paragraphs[i].isEmpty) {
                        return i;
                    }
                }
                return paragraphs.length; // Return the end if no non-empty paragraphs found
            }
            
            // Helper function to ensure scrolling to highlighted sentence works properly
            function scrollToHighlightedSentence(position, length) {
                // 1. Set selection to make Quill focus on the sentence
                quill.setSelection(position, length);
                
                // 2. Get the editor container for custom scrolling
                const editorContainer = document.querySelector('.ql-editor');
                if (!editorContainer) return;
                
                // 3. Find the DOM node containing our highlighted text
                // We'll use a more direct approach to find the highlighted element
                const highlightedElements = editorContainer.querySelectorAll('[style*="background"]');
                
                if (highlightedElements.length > 0) {
                    // Find the highlighted element that's closest to our position
                    let targetElement = highlightedElements[0];
                    
                    // Scroll the element into view with a bit of padding
                    targetElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center' // Center it in the viewport
                    });
                } else {
                    // Fallback to position-based scrolling if we can't find the element
                    // Calculate based on the position and the editor's total length
                    const totalText = quill.getText();
                    const percentPosition = position / totalText.length;
                    const scrollTarget = percentPosition * editorContainer.scrollHeight;
                    
                    // Ensure the highlighted text is centered in the viewport
                    const containerHeight = editorContainer.clientHeight;
                    const highlightHeight = 24; // Approximate line height
                    
                    editorContainer.scrollTop = Math.max(
                        0, 
                        scrollTarget - (containerHeight / 2) + (highlightHeight / 2)
                    );
                }
            }
            
            // Get the matching highlight color based on the highlight class
            function getMatchingHighlightColor(highlightClass) {
                switch (highlightClass) {
                    case 'highlight-sentence-short':
                        return 'rgba(144, 202, 249, 0.4)'; // Light blue
                    case 'highlight-sentence-medium':
                        return 'rgba(165, 214, 167, 0.4)'; // Light green
                    case 'highlight-sentence-long':
                        return 'rgba(255, 204, 128, 0.4)'; // Light orange
                    case 'highlight-sentence-extralong':
                        return 'rgba(244, 143, 177, 0.4)'; // Light pink
                    default:
                        return 'rgba(93, 92, 222, 0.3)'; // Default purple
                }
            }
            
            // Modified function to display countdown timer in any tab header
            function showCountdownTimer(seconds, timerType = 'rhythm') {
                // Get the correct timer elements based on the type
                let timerContainerId, countdownTimerId;
                
                if (timerType === 'letter') {
                    timerContainerId = 'letter-timer-container';
                    countdownTimerId = 'letter-countdown-timer';
                } else if (timerType === 'homonym') {
                    timerContainerId = 'homonym-timer-container';
                    countdownTimerId = 'homonym-countdown-timer';
                } else {
                    // Default to rhythm timer
                    timerContainerId = 'timer-container';
                    countdownTimerId = 'countdown-timer';
                }
                
                const timerContainer = document.getElementById(timerContainerId);
                const countdownTimer = document.getElementById(countdownTimerId);
                
                if (!timerContainer || !countdownTimer) {
                    console.error(`Timer elements not found for type: ${timerType}`);
                    return;
                }
                
                // Show the timer container
                timerContainer.classList.remove('hidden');
                
                // Set the initial value and CSS class for color
                countdownTimer.textContent = seconds;
                
                // Remove any existing timer classes
                countdownTimer.className = 'countdown-timer';
                // Add specific class for the current second
                countdownTimer.classList.add(`countdown-timer-${seconds}`);
                
                // Start the countdown
                let currentSecond = seconds;
                const countdownInterval = setInterval(() => {
                    currentSecond--;
                    
                    if (currentSecond <= 0) {
                        // Remove the timer when done
                        clearInterval(countdownInterval);
                        timerContainer.classList.add('hidden');
                    } else {
                        // Update text and color class for the current second
                        countdownTimer.textContent = currentSecond;
                        
                        // Remove old class and add new class for current second
                        countdownTimer.className = 'countdown-timer';
                        countdownTimer.classList.add(`countdown-timer-${currentSecond}`);
                    }
                }, 1000);
            }
            
            // Helper function to escape HTML special characters
            function escapeHtml(text) {
                return text
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }
            
            // Adjust rhythm container width based on number of sentences
            function adjustRhythmContainerWidth(sentenceCount) {
                const barWidth = getComputedStyle(document.documentElement).getPropertyValue('--rhythm-bar-width').trim() || '11px';
                const minBarWidth = parseInt(barWidth);
                const barSpacing = 2;  // Gap between bars
                const minContainerWidth = 400; // Minimum width
                
                // Calculate optimal container width
                // Each bar takes minBarWidth + barSpacing space
                const optimalWidth = Math.max(
                    minContainerWidth,
                    sentenceCount * (minBarWidth + barSpacing)
                );
                
                const rhythmContainer = document.getElementById('rhythm-container');
                const chartContainer = document.getElementById('sentence-chart');
                
                // Always make the chart container left-aligned (flex-start)
                rhythmContainer.style.overflowX = 'auto';
                chartContainer.style.width = `${optimalWidth}px`;
                chartContainer.style.justifyContent = 'flex-start';
                
                // Adjust the gap to ensure even spacing based on number of bars
                if (sentenceCount < 20) {
                    chartContainer.style.gap = '4px';
                } else {
                    chartContainer.style.gap = '2px';
                }
            }
            
            // Function specifically for analyzing letter patterns between words - with style preservation
            function analyzeHomonyms() {
                // Save current formatting
                saveEditorContents();
                
                // Get text and validate
                const text = getEditableText();
                if (!text) {
                    alert('Please enter some text to analyze.');
                    return;
                }
                
                // Reset configuration changed flag
                configurationChanged = false;
                document.getElementById('configChangedAlert').classList.add('hidden');
                
                // Set flag to indicate we've analyzed
                hasAnalyzedHomonyms = true;
                
                // First, clear any existing highlights - IMPORTANT for reanalysis
                // Clear previous highlights by applying the clean user-formatted content
                if (userFormattedContents) {
                    quill.setContents(userFormattedContents);
                }
                
                // Get configuration options
                const wordLocation = document.querySelector('.location-button.active').dataset.value;
                const wordsBetween = parseInt(document.getElementById('wordsBetweenSlider').value);
                const lettersToMatch = parseInt(document.getElementById('lettersToMatchSlider').value);
                const letterOrder = document.querySelector('input[name="letterOrder"]:checked').value;
                
                // Check if a Letter % Match option is selected
                const selectedPercentMatch = document.querySelector('input[name="matchPercent"]:checked');
                if (!selectedPercentMatch) {
                    // Show letter match error in the tab header
                    const tabHeader = document.querySelector('#homophonesTab .tab-header');
                    
                    // Check if warning already exists
                    const warningExists = document.getElementById('letterMatchErrorAlert');
                    
                    if (!warningExists) {
                        // Create error message
                        const warningEl = document.createElement('div');
                        warningEl.className = 'tab-warning warning-red w-full mt-2';
                        warningEl.id = 'letterMatchErrorAlert';
                        warningEl.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                            </svg>
                            <span>Select Letter Match % value</span>
                        `;
                        tabHeader.appendChild(warningEl);
                    }
                    return;
                }
                
                const percentMatch = parseInt(selectedPercentMatch.value);
                
                // Tokenize text more efficiently
                const textTokens = text.split(/\s+/).filter(word => word.length > 0);
                
                // Map original tokens to their processed versions (lowercase, no punctuation)
                const processedWords = textTokens.map(token => {
                    return token.replace(/[^\p{L}\p{N}]/gu, '').toLowerCase();
                });
                
                // Store matched word pairs with their exact positions
                let matchPairs = [];
                
                // Modified to ensure last word can be properly matched 
                // We now iterate through all words except the last wordsBetween
                for (let i = 0; i < processedWords.length; i++) {
                    const currentWord = processedWords[i];
                    if (!currentWord) continue; // Skip empty processed words
                    
                    // Calculate target index based on words between
                    const targetIndex = i + wordsBetween + 1;
                    
                    // Check if target index is within bounds
                    if (targetIndex < processedWords.length) {
                        const targetWord = processedWords[targetIndex];
                        if (!targetWord) continue; // Skip empty processed words
                        
                        let match = false;
                        
                        // Check for matches based on word location
                        if (wordLocation === 'startSame') {
                            match = checkStartMatch(currentWord, targetWord, lettersToMatch, letterOrder, percentMatch);
                        } else if (wordLocation === 'endSame') {
                            match = checkEndMatch(currentWord, targetWord, lettersToMatch, letterOrder, percentMatch);
                        } else if (wordLocation === 'endStartMatch') {
                            match = checkEndStartMatch(currentWord, targetWord, lettersToMatch, letterOrder, percentMatch);
                        }
                        
                        if (match) {
                            // Store the original words with their positions for highlighting
                            matchPairs.push({
                                first: {
                                    word: textTokens[i],
                                    index: i,
                                    originalWord: textTokens[i]
                                },
                                second: {
                                    word: textTokens[targetIndex],
                                    index: targetIndex,
                                    originalWord: textTokens[targetIndex]
                                }
                            });
                        }
                    }
                }
                
                // Format operations for Quill - protect existing formatting
                let formattingOperations = [];
                
                // Helper function to find the Nth occurrence of a word in text
                function findNthWordInText(text, word, n) {
                    const wordRegex = new RegExp(`\\b${escapeRegExp(word)}\\b`, 'g');
                    let count = 0;
                    let match;
                    
                    // Find the nth occurrence
                    while ((match = wordRegex.exec(text)) !== null) {
                        if (count === n) {
                            return match.index;
                        }
                        count++;
                    }
                    
                    // If we couldn't find the exact nth occurrence
                    return -1;
                }
                
                // Find each matched word in the Quill content and add a highlight operation - with position tracking
                if (matchPairs.length > 0) {
                    // Get the text content for searching
                    const editorText = quill.getText();
                    
                    // Track which word positions have been matched
                    // We'll find the specific instances of words that form matches, not all instances
                    const matchedPositions = new Map();
                    
                    // Go through each match pair and find the SPECIFIC instances of the matched words
                    matchPairs.forEach(pair => {
                        // For each pair, we need to find the corresponding word instances in the text
                        // We'll use the word positions to ensure we only highlight words that are part of matches
                        
                        // Get the positions of the words in the original text tokens
                        const firstWordIndex = pair.first.index;
                        const secondWordIndex = pair.second.index;
                        const firstWord = pair.first.originalWord;
                        const secondWord = pair.second.originalWord;
                        
                        // Find word positions in the text - for first word
                        const firstPositionKey = `${firstWord}:${firstWordIndex}`;
                        if (!matchedPositions.has(firstPositionKey)) {
                            // Find the position of this specific instance of the word
                            const firstWordPos = findNthWordInText(editorText, firstWord, firstWordIndex);
                            
                            if (firstWordPos !== -1) {
                                matchedPositions.set(firstPositionKey, {
                                    index: firstWordPos,
                                    length: firstWord.length
                                });
                                
                                // Add to formatting operations
                                formattingOperations.push({
                                    index: firstWordPos,
                                    length: firstWord.length,
                                    format: { 'background': '#5D5CDE', 'color': 'white' }
                                });
                            }
                        }
                        
                        // Find word positions in the text - for second word
                        const secondPositionKey = `${secondWord}:${secondWordIndex}`;
                        if (!matchedPositions.has(secondPositionKey)) {
                            // Find the position of this specific instance of the word
                            const secondWordPos = findNthWordInText(editorText, secondWord, secondWordIndex);
                            
                            if (secondWordPos !== -1) {
                                matchedPositions.set(secondPositionKey, {
                                    index: secondWordPos,
                                    length: secondWord.length
                                });
                                
                                // Add to formatting operations
                                formattingOperations.push({
                                    index: secondWordPos,
                                    length: secondWord.length,
                                    format: { 'background': '#5D5CDE', 'color': 'white' }
                                });
                            }
                        }
                    });
                    
                    // Store formatting operations but don't apply them automatically
                    // We'll only apply them when the user clicks on a result card
                }
                
                // Create clickable results for the detailed results panel
                const detailedResultsList = document.getElementById('detailedResultsList');
                
                if (matchPairs.length > 0) {
                    let listHTML = '';
                    
                    // Generate clickable result items for each match
                    matchPairs.forEach((pair, index) => {
                        const firstIndex = pair.first.index;
                        const secondIndex = pair.second.index;
                        
                        // Get context around matches
                        const contextBefore = textTokens.slice(Math.max(0, firstIndex-2), firstIndex).join(' ');
                        const contextBetween = textTokens.slice(firstIndex+1, secondIndex).join(' ');
                        const contextAfter = textTokens.slice(secondIndex+1, Math.min(textTokens.length, secondIndex+3)).join(' ');
                        
                        // Get the exact words
                        const firstWord = pair.first.originalWord;
                        const secondWord = pair.second.originalWord;
                        
                        // Generate token position fingerprints
                        // These identify the exact position of each token in the original text
                        // For example, "the" is token 2 in "They trailed the trek"
                        const firstTokenPosition = firstIndex; 
                        const secondTokenPosition = secondIndex;
                        
                        // Create a unique positional signature that captures the exact token positions
                        const positionSignature = `${firstTokenPosition}:${secondTokenPosition}`;
                        
                        // Create a unique match signature - combo of word positions and context
                        const matchSignature = `${contextBefore}|${firstWord}|${contextBetween}|${secondWord}|${contextAfter}`;
                        
                        // Create a more compact but still informative snippet
                        const snippet = `
                            <div class="match-result p-2 border rounded mb-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700" 
                                data-match-index="${index}" 
                                data-first-word="${firstIndex}" 
                                data-second-word="${secondIndex}" 
                                data-first-text="${firstWord}" 
                                data-second-text="${secondWord}"
                                data-position-signature="${positionSignature}"
                                data-match-signature="${encodeURIComponent(matchSignature)}">
                                <div class="truncate">...${contextBefore} <span class="highlight px-1 rounded">${firstWord}</span> ${contextBetween} <span class="highlight px-1 rounded">${secondWord}</span> ${contextAfter}...</div>
                            </div>
                        `;
                        
                        listHTML += snippet;
                    });
                    
                    detailedResultsList.innerHTML = listHTML;
                    
                    // Add click event to each result item to highlight and scroll to the match
                    document.querySelectorAll('#detailedResultsList .match-result').forEach(item => {
                        item.addEventListener('click', function() {
                            // If already highlighting a letter pattern, ignore this click
                            if (isHighlightingLetterPattern) {
                                return;
                            }
                            
                            // Set flag to prevent multiple clicks
                            isHighlightingLetterPattern = true;
                            
                            // Disable the editor to prevent clicks during highlighting
                            const editor = document.querySelector('.ql-editor');
                            if (editor) {
                                editor.style.pointerEvents = 'none';
                            }
                            
                            // Show countdown timer in the tab header - use 'letter' type
                            showCountdownTimer(4, 'letter');
                            
                            // First clear any existing highlights
                            if (userFormattedContents) {
                                quill.setContents(userFormattedContents);
                            }
                            
                            // Get data from the match card - decode HTML entities to handle quotes properly
                            const decodedFirstWord = this.dataset.firstText.replace(/&quot;/g, '"').replace(/&amp;/g, '&');
                            const decodedSecondWord = this.dataset.secondText.replace(/&quot;/g, '"').replace(/&amp;/g, '&');
                            
                            // Get the position signature which contains the exact token positions
                            const positionSignature = this.dataset.positionSignature; // format: "firstIndex:secondIndex"
                            const [firstTokenPosition, secondTokenPosition] = positionSignature.split(':').map(Number);
                            
                            // Get the current text from Quill
                            const currentText = quill.getText();
                            
                            // Try to find the words in the current text
                            const firstWordIndex = findWordInText(currentText, decodedFirstWord, firstTokenPosition);
                            const secondWordIndex = findWordInText(currentText, decodedSecondWord, secondTokenPosition);
                            
                            // Highlight and scroll to found words
                            if (firstWordIndex !== -1) {
                                // Highlight the first word - use decodedFirstWord.length for proper length
                                quill.formatText(firstWordIndex, decodedFirstWord.length, {
                                    'background': '#5D5CDE',
                                    'color': 'white'
                                }, 'api');
                                
                                // If second word is found, highlight it too
                                if (secondWordIndex !== -1) {
                                    quill.formatText(secondWordIndex, decodedSecondWord.length, {
                                        'background': '#5D5CDE',
                                        'color': 'white'
                                    }, 'api');
                                }
                                
                                // Set selection to the first word
                                quill.setSelection(firstWordIndex, decodedFirstWord.length);
                                quill.focus();
                            } else if (secondWordIndex !== -1) {
                                // Only second word found, highlight and select it
                                quill.formatText(secondWordIndex, decodedSecondWord.length, {
                                    'background': '#5D5CDE',
                                    'color': 'white'
                                }, 'api');
                                
                                quill.setSelection(secondWordIndex, decodedSecondWord.length);
                                quill.focus();
                            }
                            
                            // ALWAYS scroll the window to ensure the editor is in view
                            const editorArea = document.querySelector('.text-editor');
                            if (editorArea) {
                                // Get the position of the editor element relative to the viewport
                                const editorRect = editorArea.getBoundingClientRect();
                                
                                // Calculate how much to scroll to position the editor properly
                                const scrollBy = editorRect.top - 20; // Position with 20px padding from top
                                
                                // Smooth scroll to the editor
                                window.scrollBy({
                                    top: scrollBy,
                                    behavior: 'smooth'
                                });
                            }
                            
                            // Automatically clear highlighting after 3 seconds
                            setTimeout(() => {
                                if (userFormattedContents) {
                                    quill.setContents(userFormattedContents);
                                }
                                
                                // Release the highlighting lock and re-enable the editor after all highlighting is done
                                setTimeout(() => {
                                    isHighlightingLetterPattern = false;
                                    // Re-enable the editor
                                    if (editor) {
                                        editor.style.pointerEvents = 'auto';
                                    }
                                }, 500);
                            }, 3000);
                        });
                    });
                } else {
                    detailedResultsList.innerHTML = '<div class="text-center text-gray-500 italic">No matches found. Try adjusting your settings.</div>';
                }
                
                // Restore editor contents after highlighting to preserve original formatting
                // We've made our changes to the editor using formatText, so we don't need to restore
            }
            
            // Helper function to find a word in text around an expected position
            function findWordInText(text, word, expectedTokenPosition) {
                // Special handling for words with quotes
                const hasQuotes = word.includes('"') || word.includes("'");
                
                // First, let's try a direct string search approach which works better with quotes
                if (hasQuotes) {
                    let currentIndex = 0;
                    let foundIndex = -1;
                    let count = 0;
                    
                    // Find the Nth occurrence of the exact word
                    while (currentIndex < text.length && count <= expectedTokenPosition) {
                        const nextIndex = text.indexOf(word, currentIndex);
                        if (nextIndex === -1) break;
                        
                        foundIndex = nextIndex;
                        currentIndex = nextIndex + 1;
                        count++;
                        
                        // If we've found the expected occurrence, return it
                        if (count > expectedTokenPosition) {
                            return foundIndex;
                        }
                    }
                    
                    // If we found any occurrences but not enough, return the last one found
                    if (foundIndex !== -1) {
                        return foundIndex;
                    }
                }
                
                // For standard words without quotes, use the token-based approach
                // Split text by patterns that include line breaks and other whitespace
                const splitPattern = /(\r?\n|\s+)/;
                const parts = text.split(splitPattern).filter(Boolean);
                
                // Reconstruct tokens properly, accounting for line breaks and spaces
                const tokens = [];
                let currentPosition = 0;
                const positions = []; // Store the starting position of each token
            
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    
                    // If it's a non-whitespace token, add it
                    if (!part.match(/^\s+$/)) {
                        tokens.push(part);
                        positions.push(currentPosition);
                    }
                    
                    // Always update the current position
                    currentPosition += part.length;
                }
                
                // Try to find the expected token position directly
                if (expectedTokenPosition >= 0 && expectedTokenPosition < tokens.length) {
                    const expectedToken = tokens[expectedTokenPosition];
                    
                    // Check if token at expected position matches our word
                    if (expectedToken === word || expectedToken.trim() === word) {
                        return positions[expectedTokenPosition];
                    }
                    
                    // Special case: check nearby positions (±3) to handle potential off-by-one errors due to punctuation
                    for (let offset = -3; offset <= 3; offset++) {
                        const checkPos = expectedTokenPosition + offset;
                        if (checkPos >= 0 && checkPos < tokens.length) {
                            const nearbyToken = tokens[checkPos];
                            if (nearbyToken === word || nearbyToken.trim() === word) {
                                return positions[checkPos];
                            }
                            
                            // Additional check for tokens with punctuation or quoted words
                            if (nearbyToken.includes(word)) {
                                // Check common punctuation patterns
                                if (nearbyToken === word + '.' || nearbyToken === word + ',' || 
                                    nearbyToken === word + '!' || nearbyToken === word + '?' ||
                                    nearbyToken === '"' + word + '"' || nearbyToken === "'" + word + "'") {
                                    return positions[checkPos];
                                }
                                
                                // Check if word appears at start or end
                                if (nearbyToken.startsWith(word) || nearbyToken.endsWith(word)) {
                                    // Return position adjusted for word's location within token
                                    const wordPos = nearbyToken.indexOf(word);
                                    if (wordPos !== -1) {
                                        return positions[checkPos] + wordPos;
                                    }
                                }
                            }
                        }
                    }
                }
                
                // For words with quotes, use a plain text search as fallback
                if (hasQuotes) {
                    // Simple direct search
                    const index = text.indexOf(word);
                    if (index !== -1) {
                        return index;
                    }
                    
                    // Try with trimmed quotes
                    const trimmedWord = word.replace(/^["']|["']$/g, '');
                    const trimmedIndex = text.indexOf(trimmedWord);
                    if (trimmedIndex !== -1) {
                        return trimmedIndex;
                    }
                }
                
                // More robust fallback using regex to find all instances of the word
                try {
                    // For words with quotes, we need a different approach than word boundaries
                    let wordPattern;
                    if (hasQuotes) {
                        // Escape all regex special chars but preserve the literal quotes
                        const regexSafeWord = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                        wordPattern = new RegExp(regexSafeWord, 'g');
                    } else {
                        // Normal word boundary pattern for regular words
                        wordPattern = new RegExp(`\\b${escapeRegExp(word)}\\b`, 'g');
                    }
                    
                    let regexMatch;
                    const allMatches = [];
                    
                    // Find all occurrences in the text
                    while ((regexMatch = wordPattern.exec(text)) !== null) {
                        allMatches.push({
                            index: regexMatch.index,
                            // Store the context (a few chars before and after) to help with disambiguation
                            context: text.substring(Math.max(0, regexMatch.index - 10), 
                                                 Math.min(text.length, regexMatch.index + word.length + 10))
                        });
                    }
                    
                    if (allMatches.length > 0) {
                        // If we have multiple matches, try to identify the correct one based on position
                        
                        // First, see if we can deduce the approximate expected character position
                        let expectedCharPos = 0;
                        if (expectedTokenPosition > 0 && expectedTokenPosition < positions.length) {
                            expectedCharPos = positions[expectedTokenPosition];
                        } else if (positions.length > 0) {
                            // Extrapolate position if token position is beyond array bounds
                            const avgTokenLength = text.length / tokens.length;
                            expectedCharPos = Math.min(
                                text.length - word.length,
                                Math.max(0, Math.floor(expectedTokenPosition * avgTokenLength))
                            );
                        }
                        
                        // Find the closest match to the expected position
                        if (expectedCharPos > 0 || allMatches.length > 1) {
                            return allMatches.reduce((closest, current) => {
                                return Math.abs(current.index - expectedCharPos) < Math.abs(closest.index - expectedCharPos) 
                                    ? current : closest;
                            }, allMatches[0]).index;
                        }
                        
                        // If we only have one match or can't determine position, use the first match
                        return allMatches[0].index;
                    }
                } catch (error) {
                    console.error('Error in regex matching:', error);
                    // Try direct string search as last resort
                    return text.indexOf(word);
                }
                
                // No matches found
                return -1;
            }
            
            // Function to check start match (beginning of words)
            function checkStartMatch(word1, word2, lettersToMatch, letterOrder, percentMatch) {
                if (word1.length < lettersToMatch || word2.length < lettersToMatch) {
                    return false;
                }
                
                const prefix1 = word1.substring(0, lettersToMatch);
                const prefix2 = word2.substring(0, lettersToMatch);
                
                if (letterOrder === 'exact') {
                    if (percentMatch < 100) {
                        return checkPercentMatch(prefix1, prefix2, percentMatch);
                    }
                    return prefix1 === prefix2;
                } else {
                    // Any order
                    if (percentMatch < 100) {
                        return checkPercentMatch(prefix1, prefix2, percentMatch, true);
                    }
                    return haveSameCharacters(prefix1, prefix2);
                }
            }
            
            // Function to check end match (end of words)
            function checkEndMatch(word1, word2, lettersToMatch, letterOrder, percentMatch) {
                if (word1.length < lettersToMatch || word2.length < lettersToMatch) {
                    return false;
                }
                
                const suffix1 = word1.substring(word1.length - lettersToMatch);
                const suffix2 = word2.substring(word2.length - lettersToMatch);
                
                if (letterOrder === 'exact') {
                    if (percentMatch < 100) {
                        return checkPercentMatch(suffix1, suffix2, percentMatch);
                    }
                    return suffix1 === suffix2;
                } else {
                    // Any order
                    if (percentMatch < 100) {
                        return checkPercentMatch(suffix1, suffix2, percentMatch, true);
                    }
                    return haveSameCharacters(suffix1, suffix2);
                }
            }
            
            // Function to check end-start match (end of first word matches start of second)
            function checkEndStartMatch(word1, word2, lettersToMatch, letterOrder, percentMatch) {
                if (word1.length < lettersToMatch || word2.length < lettersToMatch) {
                    return false;
                }
                
                const suffix = word1.substring(word1.length - lettersToMatch);
                const prefix = word2.substring(0, lettersToMatch);
                
                if (letterOrder === 'exact') {
                    if (percentMatch < 100) {
                        return checkPercentMatch(suffix, prefix, percentMatch);
                    }
                    return suffix === prefix;
                } else {
                    // Any order
                    if (percentMatch < 100) {
                        return checkPercentMatch(suffix, prefix, percentMatch, true);
                    }
                    return haveSameCharacters(suffix, prefix);
                }
            }
            
            // Function to check if two strings have the same characters (any order)
            function haveSameCharacters(str1, str2) {
                if (str1.length !== str2.length) return false;
                
                const charCount1 = {};
                const charCount2 = {};
                
                for (let char of str1) {
                    charCount1[char] = (charCount1[char] || 0) + 1;
                }
                
                for (let char of str2) {
                    charCount2[char] = (charCount2[char] || 0) + 1;
                }
                
                for (let char in charCount1) {
                    if (charCount1[char] !== charCount2[char]) {
                        return false;
                    }
                }
                
                return true;
            }
            
            // Function to check percentage match of characters
            function checkPercentMatch(str1, str2, percentThreshold, anyOrder = false) {
                if (anyOrder) {
                    // For any order, we count common characters
                    const charCount1 = {};
                    const charCount2 = {};
                    
                    for (let char of str1) {
                        charCount1[char] = (charCount1[char] || 0) + 1;
                    }
                    
                    for (let char of str2) {
                        charCount2[char] = (charCount2[char] || 0) + 1;
                    }
                    
                    let commonChars = 0;
                    for (let char in charCount1) {
                        if (charCount2[char]) {
                            commonChars += Math.min(charCount1[char], charCount2[char]);
                        }
                    }
                    
                    const matchPercent = (commonChars / str1.length) * 100;
                    return matchPercent >= percentThreshold;
                } else {
                    // For exact order, we check position by position
                    let matchCount = 0;
                    for (let i = 0; i < str1.length; i++) {
                        if (str1[i] === str2[i]) {
                            matchCount++;
                        }
                    }
                    
                    const matchPercent = (matchCount / str1.length) * 100;
                    return matchPercent >= percentThreshold;
                }
            }
            
            // Handle letter match % error persistence with improved logic
            document.querySelectorAll('input[name="matchPercent"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    // Remove the error message from the tab header if it exists
                    const letterMatchErrorAlert = document.getElementById('letterMatchErrorAlert');
                    if (letterMatchErrorAlert) {
                        letterMatchErrorAlert.remove();
                    }
                    
                    // Also clear any error messages in the letterPercentMatch area
                    const errorMessage = document.querySelector('.letter-match-error');
                    if (errorMessage) {
                        errorMessage.remove();
                    }
                });
            });
            
            // Setup show/hide handlers for POS sections based on checkboxes
            document.getElementById('enablePronouns').addEventListener('change', function() {
                document.getElementById('pronounsSection').style.display = this.checked ? 'block' : 'none';
                
                // Re-analyze if we have text
                if (currentPronounText) {
                    analyzePOSAndPassive(currentPronounText);
                }
            });
            
            document.getElementById('enableAdverbs').addEventListener('change', function() {
                document.getElementById('adverbsSection').style.display = this.checked ? 'block' : 'none';
                
                // Re-analyze if we have text
                if (currentPronounText) {
                    analyzePOSAndPassive(currentPronounText);
                }
            });
            
            document.getElementById('enablePassiveVoice').addEventListener('change', function() {
                document.getElementById('passiveVoiceSection').style.display = this.checked ? 'block' : 'none';
                
                // Re-analyze if we have text
                if (currentPronounText) {
                    analyzePOSAndPassive(currentPronounText);
                }
            });
            
            // Add event listeners to pronoun checkboxes for real-time updates
            const pronounCheckboxes = document.querySelectorAll('input[name="pronouns"]');
            pronounCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    // If we already have analyzed text, update the results immediately
                    if (currentPronounText) {
                        analyzePOSAndPassive(currentPronounText);
                    }
                });
            });
            
            // Main function for POS and Passive Voice analysis - with style preservation
            function analyzePronouns(text) {
                // Save current editor state
                saveEditorContents();
                
                // Store the text for reuse when category checkboxes are toggled
                currentPronounText = text;
                
                // Call the updated analysis function
                analyzePOSAndPassive(text);
                
                // Restore editor contents
                restoreEditorContents();
            }
            
            // Function to analyze and highlight POS and passive voice - with style preservation
            function analyzePOSAndPassive(text) {
                // Get the most up-to-date text from the editable area
                // This ensures we're always working with the latest content the user has typed
                text = getEditableText();
                
                // Clear all existing highlights first by applying clean version
                // This ensures we don't have lingering highlights from previous analyses
                if (userFormattedContents) {
                    quill.setContents(userFormattedContents);
                }
                
                // Create counters for statistics
                let totalPronouns = 0;
                let totalAdverbs = 0;
                let totalPassiveVoice = 0;
                let counts = {
                    pronouns: {},
                    adverbs: 0,
                    passiveVoice: 0
                };
                
                // Get enabled categories
                const enablePronouns = document.getElementById('enablePronouns').checked;
                const enableAdverbs = document.getElementById('enableAdverbs').checked;
                const enablePassiveVoice = document.getElementById('enablePassiveVoice').checked;
                
                // Check if we need to hide any sections
                document.getElementById('pronounsSection').style.display = enablePronouns ? 'block' : 'none';
                document.getElementById('adverbsSection').style.display = enableAdverbs ? 'block' : 'none';
                document.getElementById('passiveVoiceSection').style.display = enablePassiveVoice ? 'block' : 'none';
                
                // Define pronoun regex patterns
                const pronounRegexes = {
                    'i': /\b(I|i|Me|me|My|my|Mine|mine|Myself|myself)\b/g,
                    'you': /\b(You|you|Your|your|Yours|yours|Yourself|yourself|Yourselves|yourselves)\b/g,
                    'it': /\b(It|it|Its|its|Itself|itself)\b/g,
                    'he': /\b(He|he|Him|him|His|his|Himself|himself)\b/g,
                    'she': /\b(She|she|Her|her|Hers|hers|Herself|herself)\b/g,
                    'we': /\b(We|we|Us|us|Our|our|Ours|ours|Ourselves|ourselves)\b/g,
                    'they': /\b(They|they|Them|them|Their|their|Theirs|theirs|Themselves|themselves)\b/g,
                };
                
                // Get selected pronouns (we get this directly from checkbox elements)
                const selectedPronouns = enablePronouns 
                    ? Array.from(document.querySelectorAll('input[name="pronouns"]:checked')).map(el => el.value)
                    : [];
                
                // Collect format operations
                const formattingOperations = [];
                
                // 1. Process pronouns if enabled
                if (enablePronouns) {
                    selectedPronouns.forEach(pronoun => {
                        // Reset the regex lastIndex property
                        pronounRegexes[pronoun].lastIndex = 0;
                        
                        // Count matches for statistics
                        let matches = [];
                        let match;
                        
                        // Reset regex for counting
                        pronounRegexes[pronoun].lastIndex = 0;
                        
                        while ((match = pronounRegexes[pronoun].exec(text)) !== null) {
                            matches.push({
                                index: match.index,
                                length: match[0].length,
                                text: match[0]
                            });
                            
                            // Add to counts
                            counts.pronouns[pronoun] = (counts.pronouns[pronoun] || 0) + 1;
                            totalPronouns++;
                        }
                        
                        // For each match, add a formatting operation
                        matches.forEach(m => {
                            formattingOperations.push({
                                index: m.index,
                                length: m.length,
                                format: { 
                                    'background': getPronounColor(pronoun), 
                                    'color': getPronounTextColor(pronoun) 
                                }
                            });
                        });
                    });
                }
                
                // 2. Process adverbs if enabled
                if (enableAdverbs) {
                    // Regex for common adverbs ending in -ly and other common adverbs
                    const adverbRegex = /\b(\w+ly|very|too|so|quite|rather|almost|already|almost|always|never|sometimes|usually|often|seldom|rarely)\b/gi;
                    
                    // Reset regex
                    adverbRegex.lastIndex = 0;
                    
                    // Find matches for statistics
                    let matches = [];
                    let match;
                    
                    while ((match = adverbRegex.exec(text)) !== null) {
                        matches.push({
                            index: match.index,
                            length: match[0].length,
                            text: match[0]
                        });
                        
                        counts.adverbs++;
                        totalAdverbs++;
                    }
                    
                    // For each match, add a formatting operation
                    matches.forEach(m => {
                        formattingOperations.push({
                            index: m.index,
                            length: m.length,
                            format: { 'background': '#10B981', 'color': 'white' }
                        });
                    });
                }
                
                // 3. Process passive voice if enabled
                if (enablePassiveVoice) {
                    // Fixed passive voice detection with boundary constraints
                    // 1. Detect forms of "be" + at most one word + past participle
                    // 2. Ensure the phrase doesn't cross sentence boundaries
                    
                    // Define be-verbs (including contractions 's, 're, 'm)
                    const beVerbs = /\b(am|is|are|was|were|be|been|being|'s|'re|'m)\b/gi;
                    
                    // List of common irregular past participles
                    const irregularPastParticiples = [
                        'done', 'made', 'given', 'taken', 'seen', 'known', 'shown', 'written', 
                        'found', 'sent', 'put', 'spent', 'built', 'paid', 'sold', 'bought', 
                        'heard', 'told', 'said', 'read', 'eaten', 'broken', 'chosen', 'stolen', 
                        'spoken', 'frozen', 'forgotten', 'hidden', 'wasted', 'driven', 'drawn',
                        'fallen', 'risen', 'gone', 'got', 'gotten', 'grown', 'led', 'left',
                        'lost', 'meant', 'met', 'run', 'sat', 'set', 'shaken', 'shot',
                        'sung', 'sunk', 'slept', 'slid', 'spoken', 'stood', 'swept', 'swum',
                        'swung', 'taught', 'torn', 'woken', 'won', 'worn', 'beaten', 'become',
                        'begun', 'bent', 'bet', 'bitten', 'bled', 'blown', 'brought', 'caught', 
                        'cut', 'dealt', 'dug', 'felt', 'fought', 'flown', 'flung', 'hung'
                    ];

                    // Create regex for irregular past participles
                    const irregularPattern = new RegExp(`\\b(${irregularPastParticiples.join('|')})\\b`, 'i');
                    
                    // Regular pattern for past participles (ending in -ed)
                    const regularPastParticiple = /\b\w+ed\b/i;
                    
                    // Terminal punctuation pattern
                    const terminalPunctuation = /[.!?]/;
                    
                    // Add an apostrophe detection pattern with negative lookbehind and lookahead
                    // This helps correctly handle names with apostrophes like O'Neal
                    const apostrophePattern = /(?<![a-zA-Z])'(?![a-zA-Z])/;
                    
                    // Process the text sentence by sentence to avoid crossing sentence boundaries
                    // Improved approach: keep track of punctuation and sentence positions more accurately
                    
                    // First, we'll find all sentences with their exact positions in the original text
                    const sentenceBoundaries = [];
                    let terminalPunctuationMatch;
                    const terminalPunctuationRegex = /[.!?]+/g;
                    
                    // Find all terminal punctuation
                    while ((terminalPunctuationMatch = terminalPunctuationRegex.exec(text)) !== null) {
                        sentenceBoundaries.push({
                            end: terminalPunctuationMatch.index,
                            punctuation: terminalPunctuationMatch[0]
                        });
                    }
                    
                    // Build sentences with their exact positions
                    const sentencesWithPositions = [];
                    let startPos = 0;
                    
                    for (let i = 0; i < sentenceBoundaries.length; i++) {
                        const endPos = sentenceBoundaries[i].end;
                        const punctuation = sentenceBoundaries[i].punctuation;
                        
                        // Extract sentence content (without punctuation)
                        const sentenceText = text.substring(startPos, endPos).trim();
                        
                        if (sentenceText) {
                            sentencesWithPositions.push({
                                text: sentenceText,
                                startPos: startPos,
                                endPos: endPos,
                                punctuation: punctuation
                            });
                        }
                        
                        // Next sentence starts after the punctuation
                        startPos = endPos + punctuation.length;
                    }
                    
                    // Also include any remaining text after the last punctuation
                    if (startPos < text.length) {
                        const remainingText = text.substring(startPos).trim();
                        if (remainingText) {
                            sentencesWithPositions.push({
                                text: remainingText,
                                startPos: startPos,
                                endPos: text.length,
                                punctuation: ""
                            });
                        }
                    }
                    
                    // Improved sentence processing with more precise position tracking
                    // We'll scan the original text directly to get exact positions
                    for (const sentence of sentencesWithPositions) {
                        // Get the clean sentence text (without punctuation)
                        const sentenceText = sentence.text;
                        
                        // Skip empty sentences
                        if (!sentenceText) continue;
                        
                        // Find all be-verb occurrences in this sentence
                        beVerbs.lastIndex = 0; // Reset regex state
                        let beMatch;
                        
                        while ((beMatch = beVerbs.exec(sentenceText)) !== null) {
                            const beVerb = beMatch[0];
                            const beVerbPosInSentence = beMatch.index;
                            const beVerbEnd = beVerbPosInSentence + beVerb.length;
                            
                            // Get the text after the be-verb in this sentence
                            const remainingText = sentenceText.substring(beVerbEnd);
                            
                            // Split the remaining text into words
                            const remainingWords = remainingText.trim().split(/\s+/);
                            
                            // Check for a past participle (either immediately after be-verb or with one word in between)
                            for (let i = 0; i < Math.min(2, remainingWords.length); i++) {
                                // Skip empty words
                                if (!remainingWords[i]) continue;
                                
                                const wordToCheck = remainingWords[i];
                                let isParticiple = false;
                                
                                // Check if it's a regular past participle (-ed ending)
                                if (regularPastParticiple.test(wordToCheck)) {
                                    isParticiple = true;
                                } 
                                // Check if it's an irregular past participle
                                else if (irregularPattern.test(wordToCheck)) {
                                    isParticiple = true;
                                }
                                
                                if (isParticiple) {
                                    // Find the exact position of the wordToCheck in the remaining text
                                    const participleInRemainingPos = remainingText.indexOf(wordToCheck);
                                    
                                    // Calculate the span of text from be-verb to participle
                                    const spanFromBeVerb = sentenceText.substring(beVerbPosInSentence, 
                                                            beVerbEnd + participleInRemainingPos + wordToCheck.length);
                                    
                                    // Make sure there's no terminal punctuation in between
                                    if (!terminalPunctuation.test(spanFromBeVerb.substring(0, spanFromBeVerb.length - wordToCheck.length))) {
                                        // ULTRA PRECISE position calculation:
                                        
                                        // Step 1: Get the exact string of the passive voice construction
                                        const passiveVoiceString = spanFromBeVerb;
                                        
                                        // Step 2: Get the full sentence with original context
                                        const fullContextText = text.substring(
                                            Math.max(0, sentence.startPos - 20), 
                                            Math.min(text.length, sentence.startPos + sentenceText.length + 20)
                                        );
                                        
                                        // Step 3: Find the EXACT position of the passive voice construction
                                        // by searching for it directly in the context of the original text
                                        // This is more precise than adding offsets which can drift
                                        const sentenceWithContext = text.substring(sentence.startPos);
                                        const beVerbInOriginalText = sentenceWithContext.indexOf(beVerb);
                                        
                                        if (beVerbInOriginalText !== -1) {
                                            // Get position of be-verb in original text
                                            const absoluteBeVerbStart = sentence.startPos + beVerbInOriginalText;
                                            
                                            // Find the full passive voice construction after the be-verb
                                            // We'll search for the participle starting from the be-verb position
                                            const participlePosInOriginal = sentenceWithContext.indexOf(wordToCheck, beVerbInOriginalText + beVerb.length);
                                            
                                            if (participlePosInOriginal !== -1) {
                                                // Full span calculation 
                                                const passiveStartPos = absoluteBeVerbStart;
                                                const passiveEndPos = sentence.startPos + participlePosInOriginal + wordToCheck.length;
                                                const passiveLength = passiveEndPos - passiveStartPos;
                                                
                                                // Add formatting operation for this passive voice construct
                                                formattingOperations.push({
                                                    index: passiveStartPos,
                                                    length: passiveLength,
                                                    format: { 'background': '#3B82F6', 'color': 'white' }
                                                });
                                                
                                                counts.passiveVoice++;
                                                totalPassiveVoice++;
                                            }
                                        }
                                    }
                                    
                                    // Found a match, no need to check further words
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Calculate total matches across all categories
                const totalMatches = totalPronouns + totalAdverbs + totalPassiveVoice;
                
                // Update the stats container
                const statsContainer = document.getElementById('posStatsContainer');
                const statsList = document.getElementById('posStatsList');
                
                // Show or hide "No elements found" warning
                const noElementsWarning = document.getElementById('noElementsWarning');
                
                if (totalMatches > 0) {
                    // Hide the warning
                    noElementsWarning.classList.add('hidden');
                    
                    // Apply format operations to the editor content - preserving existing formatting
                    formattingOperations.forEach(op => {
                        quill.formatText(op.index, op.length, op.format, 'api');
                    });
                    
                    // Show the stats container
                    statsContainer.classList.remove('hidden');
                    
                    // Clear previous stats
                    statsList.innerHTML = '';
                    
                    // Add pronoun stats if any
                    if (enablePronouns && totalPronouns > 0) {
                        // Add header for pronouns section
                        const pronounsHeader = document.createElement('li');
                        pronounsHeader.className = 'font-semibold bg-gray-100 dark:bg-gray-700';
                        pronounsHeader.innerHTML = `
                            <div class="pl-2">Pronouns</div>
                            <div>${totalPronouns}</div>
                        `;
                        statsList.appendChild(pronounsHeader);
                        
                        // Add individual pronouns
                        Object.entries(counts.pronouns)
                            .filter(([_, count]) => count > 0)
                            .sort((a, b) => b[1] - a[1]) // Sort by count (descending)
                            .forEach(([pronoun, count]) => {
                                const percentage = ((count / totalMatches) * 100).toFixed(1);
                                const listItem = document.createElement('li');
                                listItem.className = 'pl-4';
                                listItem.innerHTML = `
                                    <div class="flex items-center">
                                        <span class="highlight-${pronoun} inline-block w-3 h-3 mr-2 rounded"></span>
                                        <span>${pronoun.charAt(0).toUpperCase() + pronoun.slice(1)}</span>
                                    </div>
                                    <span class="item-count">${count} (${percentage}%)</span>
                                `;
                                statsList.appendChild(listItem);
                            });
                    }
                    
                    // Add adverb stats if any
                    if (enableAdverbs && counts.adverbs > 0) {
                        const adverbPercentage = ((counts.adverbs / totalMatches) * 100).toFixed(1);
                        const adverbItem = document.createElement('li');
                        adverbItem.innerHTML = `
                            <div class="flex items-center">
                                <span class="highlight-adverb inline-block w-4 h-4 mr-2 rounded"></span>
                                <span>Adverbs</span>
                            </div>
                            <span class="item-count">${counts.adverbs} (${adverbPercentage}%)</span>
                        `;
                        statsList.appendChild(adverbItem);
                    }
                    
                    // Add passive voice stats if any
                    if (enablePassiveVoice && counts.passiveVoice > 0) {
                        const passivePercentage = ((counts.passiveVoice / totalMatches) * 100).toFixed(1);
                        const passiveItem = document.createElement('li');
                        passiveItem.innerHTML = `
                            <div class="flex items-center">
                                <span class="highlight-passive inline-block w-4 h-4 mr-2 rounded"></span>
                                <span>Passive Voice</span>
                            </div>
                            <span class="item-count">${counts.passiveVoice} (${passivePercentage}%)</span>
                        `;
                        statsList.appendChild(passiveItem);
                    }
                    
                    // Update total count
                    document.getElementById('totalPosMatches').textContent = totalMatches;
                } else {
                    // No elements found
                    // Hide the stats container
                    statsContainer.classList.add('hidden');
                    
                    // Only show warning if at least one category is enabled
                    if (enablePronouns || enableAdverbs || enablePassiveVoice) {
                        // Show the warning in the tab header
                        noElementsWarning.classList.remove('hidden');
                    } else {
                        // If nothing is enabled, hide the warning
                        noElementsWarning.classList.add('hidden');
                    }
                }
            }
            
            // Helper function to get pronoun background color
            function getPronounColor(pronoun) {
                switch (pronoun) {
                    case 'i': return '#FF0000'; // Red
                    case 'you': return '#FF7F00'; // Orange
                    case 'it': return '#FFFF00'; // Yellow
                    case 'he': return '#00FF00'; // Green
                    case 'she': return '#0000FF'; // Blue
                    case 'we': return '#4B0082'; // Indigo
                    case 'they': return '#9400D3'; // Violet
                    default: return '#5D5CDE'; // Default purple
                }
            }
            
            // Helper function to get pronoun text color (for contrast)
            function getPronounTextColor(pronoun) {
                // Yellow background gets black text, all others get white
                return pronoun === 'it' ? 'black' : 'white';
            }
            
            // This is just for backward compatibility - all handled by analyzePOSAndPassive now
            function updatePronounResults() {
                if (currentPronounText) {
                    analyzePOSAndPassive(currentPronounText);
                }
            }
            
            // Function to analyze word density - with style preservation
            function analyzeDensity(text) {
                // Save current formatting
                saveEditorContents();
                
                // If text is empty, clear the word list and return
                if (!text.trim()) {
                    document.getElementById('wordList').innerHTML = '<div class="text-center text-gray-500 italic">No content to analyze</div>';
                    currentAnalyzedText = '';
                    currentWordCounts = {};
                    lastDensityText = '';
                    return;
                }
                
                // Store the text for use with the slider and for future comparison
                currentAnalyzedText = text;
                lastDensityText = text; // Update the last analyzed text
                
                // Get configuration options
                const excludeCommonWords = document.getElementById('excludeCommonWords').checked;
                // Note: we invert includeDerivatives logic since checkbox is now "Exact words"
                const exactWords = document.getElementById('includeDerivatives').checked;
                const includeDerivatives = !exactWords;
                const similarityThreshold = parseInt(document.getElementById('similarityThreshold').value);
                const analysisMode = document.querySelector('input[name="analysisMode"]:checked').value;
                
                // Update the threshold value display
                document.getElementById('thresholdValue').textContent = similarityThreshold + '%';
                
                // Update the slider state based on "Exact words" checkbox
                const thresholdSlider = document.getElementById('similarityThreshold');
                if (exactWords) {
                    thresholdSlider.disabled = true;
                    thresholdSlider.classList.add('opacity-50');
                } else {
                    thresholdSlider.disabled = false;
                    thresholdSlider.classList.remove('opacity-50');
                }
                
                // Common words to exclude if option is checked - now includes pronouns
                const commonWords = new Set([
                    // Articles, prepositions, conjunctions
                    'the', 'a', 'an', 'and', 'but', 'or', 'for', 'nor', 'of', 'on', 
                    'at', 'to', 'in', 'by', 'as', 'is', 'are', 'was', 'were', 'be', 
                    'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 
                    'shall', 'should', 'would', 'may', 'might', 'must', 'can', 'could',
                    'that', 'this', 'these', 'those', 'with', 'from', 'into',
                    // Pronouns
                    'i', 'me', 'my', 'mine', 'myself',
                    'you', 'your', 'yours', 'yourself', 'yourselves',
                    'he', 'him', 'his', 'himself',
                    'she', 'her', 'hers', 'herself',
                    'it', 'its', 'itself',
                    'we', 'us', 'our', 'ours', 'ourselves',
                    'they', 'them', 'their', 'theirs', 'themselves',
                    'who', 'whom', 'whose', 'which', 'what'
                ]);
                
                // Check if text contains CJK characters
                const isCJKText = isChineseOrJapanese(text);
                const cjkDetectionMessage = document.getElementById('cjk-detection-message');
                
                // Show CJK detection message if needed
                if (isCJKText && analysisMode === 'cjk') {
                    cjkDetectionMessage.classList.remove('hidden');
                } else {
                    cjkDetectionMessage.classList.add('hidden');
                }
                
                let words = [];
                
                if (analysisMode === 'words') {
                    // Process text into words using Unicode-aware regex (default mode)
                    words = text.split(/\s+/)
                        .map(word => word.replace(/[^\p{L}\p{N}-]/gu, '').toLowerCase())
                        .filter(word => word.length > 0)
                        .filter(word => !excludeCommonWords || !commonWords.has(word));
                } else if (analysisMode === 'cjk') {
                    // Process text using Intl.Segmenter for CJK languages if available
                    try {
                        if (typeof Intl !== 'undefined' && Intl.Segmenter) {
                            const segmenter = new Intl.Segmenter(['ja', 'zh'], { granularity: 'word' });
                            const segments = segmenter.segment(text);
                            
                            // Convert segments to an array of words
                            words = Array.from(segments)
                                .filter(segment => segment.isWordLike)
                                .map(segment => segment.segment.toLowerCase())
                                .filter(word => word.trim().length > 0);
                                
                            // Filter common words if needed (only apply to non-CJK words)
                            if (excludeCommonWords) {
                                words = words.filter(word => {
                                    // Check if this is a CJK character using Unicode ranges
                                    const isCJKWord = /[\u3000-\u303f\u3040-\u309f\u30a0-\u30ff\u3400-\u4dbf\u4e00-\u9fff\uf900-\ufaff\uff00-\uffef]/.test(word);
                                    
                                    // If it's CJK, keep it; if not, check common words
                                    return isCJKWord || !commonWords.has(word);
                                });
                            }
                        } else {
                            // Fall back to character-based analysis if Intl.Segmenter is not supported
                            console.warn("Intl.Segmenter not supported, falling back to symbol mode");
                            const cleanText = text.replace(/[^\p{L}\p{N}]/gu, '');
                            words = Array.from(cleanText);
                            
                            if (excludeCommonWords) {
                                words = words.filter(char => {
                                    const isLatinChar = /^[a-zA-Z]$/.test(char);
                                    return !isLatinChar || !commonWords.has(char.toLowerCase());
                                });
                            }
                        }
                    } catch (e) {
                        console.error("Error using Intl.Segmenter:", e);
                        // Fallback to symbol mode on error
                        const cleanText = text.replace(/[^\p{L}\p{N}]/gu, '');
                        words = Array.from(cleanText);
                        
                        if (excludeCommonWords) {
                            words = words.filter(char => {
                                const isLatinChar = /^[a-zA-Z]$/.test(char);
                                return !isLatinChar || !commonWords.has(char.toLowerCase());
                            });
                        }
                    }
                } else if (analysisMode === 'symbols') {
                    // Process text into individual characters/symbols (character-by-character)
                    const cleanText = text.replace(/[^\p{L}\p{N}]/gu, '');
                    
                    // Then split the text into individual characters
                    words = Array.from(cleanText);
                    
                    // If excludeCommonWords is checked, we still filter out Latin alphabet common words
                    // but keep all CJK characters as they're likely all meaningful
                    if (excludeCommonWords) {
                        words = words.filter(char => {
                            // Only filter out common words if they're Latin alphabet
                            const isLatinChar = /^[a-zA-Z]$/.test(char);
                            return !isLatinChar || !commonWords.has(char.toLowerCase());
                        });
                    }
                }
                
                // Count word/symbol occurrences (and store for reuse with slider)
                currentWordCounts = {};
                words.forEach(word => {
                    currentWordCounts[word] = (currentWordCounts[word] || 0) + 1;
                });
                
                // Update the word/symbol list and results - use the correct derivatives logic based on exactWords checkbox
                updateWordDensityResults(similarityThreshold, includeDerivatives);
                
                // Remove any existing density summary element
                const existingSummary = document.querySelector('.mt-4.p-2.bg-gray-100');
                if (existingSummary) existingSummary.remove();
                
                // Auto-select the first word when in Density tab
                setTimeout(() => {
                    selectFirstWordItem();
                }, 100);
                
                // Restore editor contents
                restoreEditorContents();
            }
            
            // Separate function to update word density results based on the current threshold - with style preservation
            function updateWordDensityResults(similarityThreshold, includeDerivatives = true) {
                // Remember currently selected word if any
                const activeWordItem = document.querySelector('.word-item.active');
                let activeWordGroup = null;
                if (activeWordItem) {
                    activeWordGroup = activeWordItem.dataset.word;
                }
                
                // Exit if no text has been analyzed yet
                if (!currentAnalyzedText || Object.keys(currentWordCounts).length === 0) {
                    return;
                }
                
                const wordGroups = {}; // For derivative grouping
                const processedWords = new Set(); // To track which words have been processed
                
                // Group words based on current similarity threshold
                if (includeDerivatives) {
                    // Initialize word groups
                    Object.keys(currentWordCounts).forEach(word => {
                        if (!processedWords.has(word)) {
                            const group = [word];
                            processedWords.add(word);
                            
                            // Find derivatives
                            Object.keys(currentWordCounts).forEach(otherWord => {
                                if (!processedWords.has(otherWord) && word !== otherWord) {
                                    const similarity = calculateSimilarity(word, otherWord);
                                    if (similarity >= similarityThreshold) {
                                        group.push(otherWord);
                                        processedWords.add(otherWord);
                                    }
                                }
                            });
                            
                            // If group has multiple words, create a group entry
                            if (group.length > 1) {
                                const groupKey = group[0]; // First word as key
                                wordGroups[groupKey] = {
                                    words: group,
                                    count: group.reduce((sum, w) => sum + currentWordCounts[w], 0)
                                };
                            } else {
                                // If no derivatives, just use the original count
                                wordGroups[word] = {
                                    words: [word],
                                    count: currentWordCounts[word]
                                };
                            }
                        }
                    });
                } else {
                    // If derivatives not enabled, just use individual word counts
                    Object.keys(currentWordCounts).forEach(word => {
                        wordGroups[word] = {
                            words: [word],
                            count: currentWordCounts[word]
                        };
                    });
                }
                
                // Sort groups by count (descending) and filter for counts of 2 or more
                const sortedGroups = Object.entries(wordGroups)
                    .filter(([_, data]) => data.count >= 2) // Only include words that appear 2 or more times
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, 50); // Limit to top 50 words/groups
                
                // Update the word list
                const wordListEl = document.getElementById('wordList');
                if (sortedGroups.length > 0) {
                    let listHTML = '';
                    sortedGroups.forEach(([word, data]) => {
                        const displayWord = word.charAt(0).toUpperCase() + word.slice(1);
                        let derivatives = '';
                        
                        if (data.words.length > 1) {
                            const derivativesList = data.words
                                .filter(w => w !== word)
                                .map(w => w.charAt(0).toUpperCase() + w.slice(1))
                                .join(', ');
                            derivatives = `<small class="text-gray-500 block">Includes: ${derivativesList}</small>`;
                        }
                        
                        // Check if this was the previously active word
                        const isActive = activeWordGroup === word;
                        const activeClass = isActive ? 'active' : '';
                        
                        listHTML += `
                            <div class="word-item ${activeClass}" data-word="${word}" data-group='${JSON.stringify(data.words)}'>
                                <div class="word-details">
                                    <span class="word-text">${displayWord}</span>
                                    ${derivatives}
                                </div>
                                <div class="word-count font-medium ml-2">${data.count}</div>
                            </div>
                        `;
                    });
                    wordListEl.innerHTML = listHTML;
                    
                    // Add click event to word items
                    document.querySelectorAll('.word-item').forEach(item => {
                        item.addEventListener('click', function() {
                            // Save current formatting
                            saveEditorContents();
                            
                            // Remove active class from all items
                            document.querySelectorAll('.word-item').forEach(i => i.classList.remove('active'));
                            // Add active class to clicked item
                            this.classList.add('active');
                            
                            // Get the word group data
                            const groupWords = JSON.parse(this.dataset.group);
                            
                            // Highlight word and derivatives in the text
                            highlightWordGroupInText(currentAnalyzedText, groupWords);
                        });
                    });
                    
                    // Re-highlight the active word if it exists in the new list
                    const newActiveItem = document.querySelector('.word-item.active');
                    if (newActiveItem) {
                        const groupWords = JSON.parse(newActiveItem.dataset.group);
                        highlightWordGroupInText(currentAnalyzedText, groupWords);
                    }
                } else {
                    wordListEl.innerHTML = '<div class="text-center text-gray-500 italic">No words found or all words filtered out</div>';
                }
            }
            
            // Calculate word similarity (as percentage)
            function calculateSimilarity(word1, word2) {
                // Simple variant of Levenshtein distance to determine similarity
                if (word1 === word2) return 100;
                
                // Check if one contains the other
                if (word1.includes(word2) || word2.includes(word1)) {
                    const longerLength = Math.max(word1.length, word2.length);
                    const shorterLength = Math.min(word1.length, word2.length);
                    return Math.round((shorterLength / longerLength) * 100);
                }
                
                // Check common prefix/suffix
                const minLength = Math.min(word1.length, word2.length);
                let commonPrefix = 0;
                for (let i = 0; i < minLength; i++) {
                    if (word1[i] === word2[i]) {
                        commonPrefix++;
                    } else {
                        break;
                    }
                }
                
                let commonSuffix = 0;
                for (let i = 1; i <= minLength; i++) {
                    if (word1[word1.length - i] === word2[word2.length - i]) {
                        commonSuffix++;
                    } else {
                        break;
                    }
                }
                
                const commonLength = Math.max(commonPrefix, commonSuffix);
                const similarity = (commonLength / Math.max(word1.length, word2.length)) * 100;
                
                return Math.round(similarity);
            }
            
            // Highlight a word group in the text with QuillJS formatting - with style preservation
            function highlightWordGroupInText(text, wordGroup) {
                // Store current scroll position
                const editorContainer = document.querySelector('.ql-editor');
                const currentScrollPosition = editorContainer ? editorContainer.scrollTop : 0;
                
                // Get the current text from the quill editor
                const quillContent = quill.getText();
                
                // Check which analysis mode we're in
                const analysisMode = document.querySelector('input[name="analysisMode"]:checked').value;
                
                // Define the density highlight color 
                const densityHighlightColor = getComputedStyle(document.documentElement).getPropertyValue('--density-highlight').trim() || '#9C27B0';
                
                // Important: Clear ALL existing highlights first
                // Step 1: Apply the cleaned version (without any highlights)
                if (userFormattedContents) {
                    quill.setContents(userFormattedContents);
                }
                
                // Step 2: Double check by directly removing any background formatting
                const cleanContents = quill.getContents();
                if (cleanContents && cleanContents.ops) {
                    const completelyCleanContents = JSON.parse(JSON.stringify(cleanContents));
                    completelyCleanContents.ops.forEach(op => {
                        if (op.attributes) {
                            delete op.attributes.background;
                            delete op.attributes.color;
                            // Clean up empty attributes objects
                            if (Object.keys(op.attributes).length === 0) {
                                delete op.attributes;
                            }
                        }
                    });
                    
                    // Apply the aggressively cleaned content
                    quill.setContents(completelyCleanContents);
                }
                
                // Now get the completely clean text content again (with user formatting but no highlights)
                const cleanQuillContent = quill.getText();
                
                // Detect if we're dealing with RTL script (Hebrew, Arabic, etc.)
                function isRTLScript(text) {
                    // Hebrew characters range: \u0590-\u05FF
                    // Arabic characters range: \u0600-\u06FF
                    // Arabic supplement range: \u0750-\u077F
                    // Arabic extended range: \u08A0-\u08FF
                    // Other RTL scripts...
                    const rtlPattern = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF]/;
                    return rtlPattern.test(text);
                }
                
                // Function to find all matches of a word in text, supporting non-Latin scripts
                function findAllMatches(text, word) {
                    const matches = [];
                    let lastIndex = 0;
                    const searchWord = word.toLowerCase();
                    const searchText = text.toLowerCase();
                    
                    // For non-Latin scripts, we need a special approach for word boundaries
                    if (isRTLScript(word) || analysisMode !== 'words') {
                        // For RTL or non-word mode, just find all exact occurrences
                        while (lastIndex < searchText.length) {
                            const index = searchText.indexOf(searchWord, lastIndex);
                            if (index === -1) break;
                            
                            // Check if this is a standalone word (by checking boundaries)
                            // For RTL scripts, we use a more general approach
                            const prevChar = index > 0 ? searchText.charAt(index - 1) : ' ';
                            const nextChar = index + searchWord.length < searchText.length ? 
                                searchText.charAt(index + searchWord.length) : ' ';
                            
                            // Either it's not word mode, or we check if the char before/after is a non-word char
                            if (analysisMode !== 'words' || 
                                (/[^\p{L}\p{N}]/u.test(prevChar) && /[^\p{L}\p{N}]/u.test(nextChar))) {
                                matches.push({
                                    index: index,
                                    length: searchWord.length
                                });
                            }
                            
                            lastIndex = index + 1; // Move past this match
                        }
                    } else {
                        // For Latin scripts in word mode, use standard word boundary approach
                        const wordRegex = new RegExp(`\\b${escapeRegExp(word)}\\b`, 'gi');
                        let match;
                        
                        // Reset regex before using
                        wordRegex.lastIndex = 0;
                        
                        while ((match = wordRegex.exec(text)) !== null) {
                            matches.push({
                                index: match.index,
                                length: match[0].length
                            });
                        }
                    }
                    
                    return matches;
                }
                
                // Store all matches to track the first occurrence
                let allMatches = [];
                
                // Process each word/symbol in the group
                wordGroup.forEach(word => {
                    if (!word) return; // Skip empty words
                    
                    // Find all occurrences with our improved matching function
                    const matches = findAllMatches(cleanQuillContent, word);
                    
                    // Store all matches for later reference
                    allMatches = allMatches.concat(matches);
                    
                    // Apply formatting to all matches
                    matches.forEach(match => {
                        quill.formatText(match.index, match.length, {
                            'background': densityHighlightColor,
                            'color': 'white'
                        }, 'api');
                    });
                });
                
                // Set selection to the first match without scrolling
                if (allMatches.length > 0) {
                    // Sort matches by position to find the first one
                    allMatches.sort((a, b) => a.index - b.index);
                    const firstMatch = allMatches[0];
                    
                    // Set selection without scrolling
                    quill.setSelection(firstMatch.index, firstMatch.length, 'silent');
                }
                
                // Restore the original scroll position
                if (editorContainer) {
                    setTimeout(() => {
                        editorContainer.scrollTop = currentScrollPosition;
                    }, 10);
                }
            }
            
            // Helper function to escape special regex characters
            function escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }
            
            // Auto-select the first word item when analysis completes
            function selectFirstWordItem() {
                const firstWordItem = document.querySelector('.word-item');
                if (firstWordItem) {
                    // Simulate click on first word to select it
                    firstWordItem.click();
                }
            }
            
            // Update threshold value and recalculate word density when slider is moved
            document.getElementById('similarityThreshold').addEventListener('input', function() {
                const newThreshold = parseInt(this.value);
                document.getElementById('thresholdValue').textContent = newThreshold + '%';
                
                // Get the current include derivatives setting (inverted since checkbox is now "Exact words")
                const exactWords = document.getElementById('includeDerivatives').checked;
                const includeDerivatives = !exactWords;
                
                // Save current formatting
                saveEditorContents();
                
                // Dynamically update the word list and highlighted words based on new threshold
                updateWordDensityResults(newThreshold, includeDerivatives);
            });
            
            // Also update when "Exact words" (previously "include derivatives") checkbox is toggled
            document.getElementById('includeDerivatives').addEventListener('change', function() {
                const similarityThreshold = parseInt(document.getElementById('similarityThreshold').value);
                const thresholdSlider = document.getElementById('similarityThreshold');
                
                // If "Exact words" is checked, disable the threshold slider
                if (this.checked) {
                    thresholdSlider.disabled = true;
                    thresholdSlider.classList.add('opacity-50');
                } else {
                    thresholdSlider.disabled = false;
                    thresholdSlider.classList.remove('opacity-50');
                }
                
                // Save current formatting
                saveEditorContents();
                
                // Note: for "Exact words", we actually want includeDerivatives to be FALSE
                updateWordDensityResults(similarityThreshold, !this.checked);
            });
            
            // And update when exclude common words is toggled
            document.getElementById('excludeCommonWords').addEventListener('change', function() {
                // For this one, we need to fully reanalyze the text since word filtering changes
                if (currentAnalyzedText) {
                    analyzeDensity(currentAnalyzedText);
                }
            });
            
            // Add an event listener to re-analyze when the analysis mode changes
            document.querySelectorAll('input[name="analysisMode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    // If we already have analyzed text, re-analyze with the new mode
                    if (currentAnalyzedText) {
                        analyzeDensity(currentAnalyzedText);
                    }
                });
            });
            
            // Save and load analysis mode preference from localStorage
            function initAnalysisModeSelection() {
                try {
                    // Ensure Words is selected by default initially
                    document.querySelector('input[name="analysisMode"][value="words"]').checked = true;
                    
                    // Check if this is the first visit (ensures Words is only selected on first load)
                    const hasVisitedBefore = localStorage.getItem('wordPatternAnalyzerFirstVisit');
                    
                    if (hasVisitedBefore) {
                        // Not first visit, load user's saved preference
                        const savedAnalysisMode = localStorage.getItem('wordPatternAnalyzerMode');
                        if (savedAnalysisMode) {
                            // Set the radio button corresponding to the saved mode
                            const radioButton = document.querySelector(`input[name="analysisMode"][value="${savedAnalysisMode}"]`);
                            if (radioButton) {
                                radioButton.checked = true;
                            }
                        }
                    } else {
                        // First visit - simply mark as visited (Words already selected as default above)
                        localStorage.setItem('wordPatternAnalyzerFirstVisit', 'true');
                    }
                    
                    // Save analysis mode preference when changed
                    document.querySelectorAll('input[name="analysisMode"]').forEach(radio => {
                        radio.addEventListener('change', function() {
                            localStorage.setItem('wordPatternAnalyzerMode', this.value);
                        });
                    });
                } catch (error) {
                    console.error('Error handling analysis mode preference:', error);
                    // Ensure Words is selected as fallback
                    document.querySelector('input[name="analysisMode"][value="words"]').checked = true;
                }
            }
            
            // Call this immediately after DOMContentLoaded
            initAnalysisModeSelection();
            
            //======================================
            // CUSTOM SETS FUNCTIONALITY
            //======================================
            
            // Define color palette for custom sets
            const colorPalette = [
                "#FF5733", "#C70039", "#900C3F", "#581845", // Reds/Purples
                "#FFC300", "#FF5733", "#C70039", "#900C3F", // Yellows/Oranges
                "#2ECC71", "#27AE60", "#1E8449", "#145A32", // Greens
                "#3498DB", "#2980B9", "#1F618D", "#154360", // Blues
                "#9B59B6", "#8E44AD", "#6C3483", "#4A235A", // Purples
                "#34495E", "#2C3E50", "#212F3D", "#17202A"  // Dark Blues
            ];
            
            // Custom sets array to store all user-defined sets
            let customSets = [];
            // Array to track which sets are active
            let activeSets = [];
            // Current set being edited (if any)
            let currentEditingSet = null;
            
            // Initialize custom sets UI
            function initCustomSets() {
                try {
                    // Try to load saved sets from localStorage
                    const savedSets = localStorage.getItem('wordPatternAnalyzerCustomSets');
                    if (savedSets) {
                        customSets = JSON.parse(savedSets);
                        // Load active sets
                        const savedActiveSets = localStorage.getItem('wordPatternAnalyzerActiveSets');
                        if (savedActiveSets) {
                            activeSets = JSON.parse(savedActiveSets);
                        }
                    }
                } catch (error) {
                    console.error('Error loading custom sets:', error);
                    // If there's an error, initialize with empty arrays
                    customSets = [];
                    activeSets = [];
                }
                
                // Populate color picker
                populateColorPicker();
                
                // Set up event listeners
                document.getElementById('createSetBtn').addEventListener('click', showNewSetForm);
                document.getElementById('saveSetBtn').addEventListener('click', saveCustomSet);
                document.getElementById('cancelEditBtn').addEventListener('click', hideSetForm);
                document.getElementById('exportSetsBtn').addEventListener('click', exportCustomSets);
                document.getElementById('importSetsBtn').addEventListener('click', importCustomSets);
                
                // Initial UI render
                renderCustomSetsList();
                updateActiveSets();
                
                // Initially hide the form
                hideSetForm();
            }
            
            // Populate the color picker with color options
            function populateColorPicker() {
                const colorPickerEl = document.getElementById('colorPicker');
                colorPickerEl.innerHTML = '';
                
                colorPalette.forEach((color, index) => {
                    const colorOption = document.createElement('div');
                    colorOption.className = 'color-option';
                    colorOption.style.backgroundColor = color;
                    colorOption.dataset.color = color;
                    colorOption.title = `Color ${index + 1}`;
                    
                    // Select first color by default for new sets
                    if (index === 0 && !currentEditingSet) {
                        colorOption.classList.add('selected');
                    }
                    
                    colorOption.addEventListener('click', function() {
                        // Remove selected class from all options
                        document.querySelectorAll('.color-option').forEach(option => 
                            option.classList.remove('selected'));
                        // Add selected class to clicked option
                        this.classList.add('selected');
                    });
                    
                    colorPickerEl.appendChild(colorOption);
                });
            }
            
            // Save custom sets to localStorage
            function saveCustomSets() {
                try {
                    localStorage.setItem('wordPatternAnalyzerCustomSets', JSON.stringify(customSets));
                    localStorage.setItem('wordPatternAnalyzerActiveSets', JSON.stringify(activeSets));
                } catch (error) {
                    console.error('Error saving custom sets:', error);
                }
            }
            
            // Render the list of custom sets
            function renderCustomSetsList() {
                const listContainer = document.getElementById('customSetsList');
                
                if (customSets.length === 0) {
                    listContainer.innerHTML = '<div class="text-center text-gray-500 dark:text-gray-400 italic">No custom sets yet</div>';
                    return;
                }
                
                let listHTML = '';
                customSets.forEach(set => {
                    // Check if this set is active
                    const isActive = activeSets.includes(set.id);
                    
                    listHTML += `
                        <div class="custom-set-item ${isActive ? 'active' : ''}" data-id="${set.id}" style="border-left-color: ${set.color}">
                            <div class="flex justify-between items-start">
                                <div class="flex items-start">
                                    <div class="mr-2 mt-1">
                                        <input type="checkbox" id="set-${set.id}" class="set-checkbox w-4 h-4 rounded border-gray-300 focus:ring-indigo-500 dark:border-gray-600 dark:bg-gray-700" data-id="${set.id}" ${isActive ? 'checked' : ''}>
                                    </div>
                                    <div>
                                        <div class="flex items-center">
                                            <span class="color-swatch" style="background-color: ${set.color}"></span>
                                            <label for="set-${set.id}" class="cursor-pointer"><strong>${set.name}</strong></label>
                                        </div>
                                        <div class="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                            ${set.words.length} word${set.words.length !== 1 ? 's' : ''}
                                        </div>
                                    </div>
                                </div>
                                <div class="flex space-x-1">
                                    <button class="edit-set-btn p-1 text-gray-600 hover:text-indigo-600 dark:text-gray-400 dark:hover:text-indigo-400" data-id="${set.id}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                                        </svg>
                                    </button>
                                    <button class="delete-set-btn p-1 text-gray-600 hover:text-red-500 dark:text-gray-400 dark:hover:text-red-400" data-id="${set.id}">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                listContainer.innerHTML = listHTML;
                
                // Add event listeners
                // 1. Checkbox click to toggle active state
                document.querySelectorAll('.set-checkbox').forEach(checkbox => {
                    checkbox.addEventListener('change', function(e) {
                        e.stopPropagation(); // Prevent item click event
                        const setId = this.dataset.id;
                        toggleSetActive(setId);
                        updatePreview(setId);
                    });
                });
                
                // 2. Click on set item to toggle checkbox
                document.querySelectorAll('.custom-set-item').forEach(item => {
                    item.addEventListener('click', function(e) {
                        // Don't toggle if clicking on buttons or checkbox directly
                        if (e.target.closest('.edit-set-btn') || 
                            e.target.closest('.delete-set-btn') || 
                            e.target.closest('.set-checkbox')) {
                            return;
                        }
                        
                        // Find the checkbox and toggle it
                        const checkbox = this.querySelector('.set-checkbox');
                        checkbox.checked = !checkbox.checked;
                        
                        // Trigger the change event on the checkbox
                        const changeEvent = new Event('change');
                        checkbox.dispatchEvent(changeEvent);
                    });
                });
                
                // 3. Edit button
                document.querySelectorAll('.edit-set-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent toggling the set
                        const setId = this.dataset.id;
                        editCustomSet(setId);
                    });
                });
                
                // 4. Delete button
                document.querySelectorAll('.delete-set-btn').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation(); // Prevent toggling the set
                        const setId = this.dataset.id;
                        deleteCustomSet(setId);
                    });
                });
            }
           
            // Toggle a set's active state
            function toggleSetActive(setId) {
                const index = activeSets.indexOf(setId);
                if (index === -1) {
                    // Add to active sets
                    activeSets.push(setId);
                } else {
                    // Remove from active sets
                    activeSets.splice(index, 1);
                }
                
                // Update UI - both checkbox and the container class
                const setItem = document.querySelector(`.custom-set-item[data-id="${setId}"]`);
                if (setItem) {
                    setItem.classList.toggle('active');
                    // Also update checkbox state to match active state
                    const checkbox = setItem.querySelector(`.set-checkbox`);
                    if (checkbox) {
                        checkbox.checked = activeSets.includes(setId);
                    }
                }
                
                // Update active sets container
                updateActiveSets();
                
                // Save to localStorage
                saveCustomSets();
                
                // If we already have text in the textarea, re-analyze with new active sets
                const text = getEditableText();
                if (text) {
                    updateCustomSetPreview(text);
                }
            }
            
            // Update the active sets container
            function updateActiveSets() {
                const container = document.getElementById('activeSetsContainer');
                
                if (activeSets.length === 0) {
                    container.innerHTML = '<p class="italic text-gray-500 dark:text-gray-400 text-center w-full">No active sets. Select sets from the list to activate them.</p>';
                    return;
                }
                
                let html = '';
                activeSets.forEach(setId => {
                    const set = customSets.find(s => s.id === setId);
                    if (set) {
                        html += `
                            <div class="inline-flex items-center bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-full px-3 py-1 text-sm">
                                <span class="color-swatch" style="background-color:${set.color};width:12px;height:12px;margin-right:4px;"></span>
                                <span>${set.name}</span>
                            </div>
                        `;
                    }
                });
                
                container.innerHTML = html;
            }
            
            // Show new set form
            function showNewSetForm() {
                const formContainer = document.getElementById('setEditForm');
                formContainer.style.display = 'block';
                
                // Clear form fields
                document.getElementById('setName').value = '';
                document.getElementById('setWords').value = '';
                
                // Set regex pattern matching OFF by default
                document.getElementById('useRegexMatch').checked = false;
                
                // Reset color picker to first color
                document.querySelectorAll('.color-option').forEach((option, index) => {
                    option.classList.toggle('selected', index === 0);
                });
                
                // Reset current editing set
                currentEditingSet = null;
                
                // Clear any existing error messages
                clearFormErrors();
            }
            
            // Hide set form
            function hideSetForm() {
                document.getElementById('setEditForm').style.display = 'none';
                currentEditingSet = null;
                clearFormErrors();
            }
            
            // Validate custom set form
            function validateCustomSetForm() {
                clearFormErrors();
                let isValid = true;
                
                // Validate set name
                const setName = document.getElementById('setName').value.trim();
                if (!setName) {
                    showFormError('setName', 'Set name is required');
                    isValid = false;
                }
                
                // Validate words
                const wordsText = document.getElementById('setWords').value.trim();
                if (!wordsText) {
                    showFormError('setWords', 'At least one word is required');
                    isValid = false;
                } else {
                    // Check word count
                    const words = wordsText.split(',')
                        .map(word => word.trim())
                        .filter(word => word.length > 0);
                    
                    if (words.length === 0) {
                        showFormError('setWords', 'Please enter at least one valid word');
                        isValid = false;
                    } else if (words.length > 30) {
                        showFormError('setWords', 'Too many words. Maximum 30 words allowed.');
                        isValid = false;
                    }
                }
                
                return isValid;
            }
            
            // Show form error
            function showFormError(fieldId, message) {
                const field = document.getElementById(fieldId);
                field.classList.add('error-border');
                
                // Create error message element if it doesn't exist
                let errorEl = field.nextElementSibling;
                if (!errorEl || !errorEl.classList.contains('form-error')) {
                    errorEl = document.createElement('div');
                    errorEl.className = 'form-error';
                    field.parentNode.insertBefore(errorEl, field.nextElementSibling);
                }
                
                errorEl.textContent = message;
            }
            
            // Clear form errors
            function clearFormErrors() {
                // Remove all error highlighting and messages
                const formFields = document.querySelectorAll('#setEditForm input, #setEditForm textarea');
                formFields.forEach(field => {
                    field.classList.remove('error-border');
                    const next = field.nextElementSibling;
                    if (next && next.classList.contains('form-error')) {
                        next.remove();
                    }
                });
            }
            
            // Save custom set (new or edited) - with style preservation
            function saveCustomSet() {
                // Validate form
                if (!validateCustomSetForm()) {
                    return;
                }
                
                const name = document.getElementById('setName').value.trim();
                
                // Get words and normalize them
                const wordsText = document.getElementById('setWords').value.trim();
                
                // Split words by commas, trim whitespace, and remove empty entries
                const words = wordsText.split(',')
                    .map(word => word.trim())
                    .filter(word => word.length > 0);
                
                // Get selected color
                const selectedColor = document.querySelector('.color-option.selected').dataset.color;
                
                // Check if using regex
                const useRegex = document.getElementById('useRegexMatch').checked;
                
                // Create or update set
                if (currentEditingSet) {
                    // Update existing set
                    const setIndex = customSets.findIndex(set => set.id === currentEditingSet);
                    if (setIndex !== -1) {
                        customSets[setIndex] = {
                            ...customSets[setIndex],
                            name,
                            color: selectedColor,
                            words,
                            useRegex
                        };
                    }
                } else {
                    // Create new set
                    // Check if we've reached the limit
                    if (customSets.length >= 10) {
                        alert('You can only create up to 10 custom sets. Please delete some existing sets first.');
                        return;
                    }
                    
                    // Generate unique ID
                    const newId = 'set_' + Date.now();
                    
                    // Add new set
                    customSets.push({
                        id: newId,
                        name,
                        color: selectedColor,
                        words,
                        useRegex
                    });
                    
                    // Activate the new set by default
                    activeSets.push(newId);
                }
                
                // Save to localStorage
                saveCustomSets();
                
                // Update UI
                renderCustomSetsList();
                updateActiveSets();
                hideSetForm();
                
                // Show success message
                const successMessage = document.createElement('div');
                successMessage.className = 'fixed bottom-4 right-4 bg-green-100 border-l-4 border-green-500 text-green-700 p-4 rounded shadow-lg z-50';
                successMessage.innerHTML = `
                    <div class="flex">
                        <div class="py-1"><svg class="fill-current h-6 w-6 text-green-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM6.7 9.29L9 11.6l4.3-4.3 1.4 1.42L9 14.4l-3.7-3.7 1.4-1.42z"/></svg></div>
                        <div>
                            <p class="font-bold">Success!</p>
                            <p class="text-sm">Your custom set "${name}" has been ${currentEditingSet ? 'updated' : 'created'}.</p>
                        </div>
                    </div>
                `;
                document.body.appendChild(successMessage);
                
                // Remove success message after 3 seconds
                setTimeout(() => {
                    successMessage.remove();
                }, 3000);
                
                // If we already have text in the textarea, preview the new set
                const text = getEditableText();
                if (text) {
                    updateCustomSetPreview(text);
                }
            }
            
            // Edit custom set
            function editCustomSet(setId) {
                const set = customSets.find(s => s.id === setId);
                if (!set) return;
                
                // Set current editing set
                currentEditingSet = setId;
                
                // Populate form
                document.getElementById('setName').value = set.name;
                document.getElementById('setWords').value = set.words.join(', ');
                document.getElementById('useRegexMatch').checked = set.useRegex || false;
                
                // Select the correct color
                document.querySelectorAll('.color-option').forEach(option => {
                    option.classList.toggle('selected', option.dataset.color === set.color);
                });
                
                // Show form
                document.getElementById('setEditForm').style.display = 'block';
                
                // Clear any existing error messages
                clearFormErrors();
            }
            
            // Delete custom set
            function deleteCustomSet(setId) {
                if (!confirm('Are you sure you want to delete this set? This action cannot be undone.')) {
                    return;
                }
                
                // Remove set from customSets
                const setIndex = customSets.findIndex(set => set.id === setId);
                if (setIndex !== -1) {
                    const setName = customSets[setIndex].name;
                    customSets.splice(setIndex, 1);
                    
                    // Remove from active sets if present
                    const activeIndex = activeSets.indexOf(setId);
                    if (activeIndex !== -1) {
                        activeSets.splice(activeIndex, 1);
                    }
                    
                    // Save to localStorage
                    saveCustomSets();
                    
                    // Update UI
                    renderCustomSetsList();
                    updateActiveSets();
                    
                    // Show success message
                    const successMessage = document.createElement('div');
                    successMessage.className = 'fixed bottom-4 right-4 bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded shadow-lg z-50';
                    successMessage.innerHTML = `
                        <div class="flex">
                            <div class="py-1"><svg class="fill-current h-6 w-6 text-red-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM7.5 7.5A.5.5 0 0 1 8 8v6a.5.5 0 0 1-1 0V8a.5.5 0 0 1 .5-.5zm5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V8a.5.5 0 0 1 .5-.5z"/></svg></div>
                            <div>
                                <p class="font-bold">Deleted!</p>
                                <p class="text-sm">The set "${setName}" has been deleted.</p>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(successMessage);
                    
                    // Remove success message after 3 seconds
                    setTimeout(() => {
                        successMessage.remove();
                    }, 3000);
                    
                    // If we already have text in the textarea, update preview
                    const text = getEditableText();
                    if (text) {
                        updateCustomSetPreview(text);
                    }
                }
            }
            
            // Export custom sets to JSON file
            function exportCustomSets() {
                if (customSets.length === 0) {
                    alert('You don\'t have any custom sets to export.');
                    return;
                }
                
                const exportData = {
                    customSets,
                    activeSets,
                    exportDate: new Date().toISOString(),
                    appVersion: '1.0'
                };
                
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                // Create a temporary link and click it
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = 'word-analyzer-custom-sets.json';
                
                // This approach requires user to right-click and "Save link as"
                // due to Canvas App download restrictions
                const exportDialog = document.createElement('div');
                exportDialog.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                exportDialog.innerHTML = `
                    <div class="bg-white dark:bg-gray-800 p-6 rounded-lg max-w-md w-full">
                        <h3 class="text-lg font-semibold mb-4">Export Custom Sets</h3>
                        <p class="mb-4">Your browser's security settings prevent direct file downloads. Please:</p>
                        <ol class="list-decimal pl-5 mb-4 space-y-2">
                            <li>Right-click the link below</li>
                            <li>Select "Save link as" or similar option</li>
                            <li>Save the file to your computer</li>
                        </ol>
                        <div class="mb-4">
                            <a href="${url}" target="_blank" class="text-indigo-600 hover:text-indigo-800 dark:text-indigo-400 dark:hover:text-indigo-300 underline font-medium">word-analyzer-custom-sets.json</a>
                        </div>
                        <button class="close-export-dialog w-full bg-gray-300 hover:bg-gray-400 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-white font-medium py-2 px-4 rounded">Close</button>
                    </div>
                `;
                document.body.appendChild(exportDialog);
                
                // Add close functionality
                exportDialog.querySelector('.close-export-dialog').addEventListener('click', function() {
                    exportDialog.remove();
                    URL.revokeObjectURL(url); // Clean up the URL object
                });
            }
            
            // Import custom sets from JSON file - adds to existing sets instead of replacing
            function importCustomSets() {
                // Create a file input element
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.json,application/json';
                
                fileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importData = JSON.parse(e.target.result);
                            
                            // Validate import data
                            if (!importData.customSets || !Array.isArray(importData.customSets)) {
                                throw new Error('Invalid import file format');
                            }
                            
                            // Get confirmation for adding sets (not replacing)
                            const message = customSets.length > 0 ? 
                                `This will add ${importData.customSets.length} new set(s) to your existing ${customSets.length} set(s). Continue?` :
                                `Import ${importData.customSets.length} set(s)?`;
                            
                            if (!confirm(message)) {
                                return;
                            }
                            
                            // Generate new IDs for imported sets to avoid conflicts
                            const importedSetsWithNewIds = importData.customSets.map(set => {
                                // Create a name that avoids conflicts
                                let newName = set.name;
                                let nameCounter = 1;
                                
                                // Check if name already exists
                                while (customSets.some(existingSet => existingSet.name === newName)) {
                                    newName = `${set.name} (${nameCounter})`;
                                    nameCounter++;
                                }
                                
                                return {
                                    ...set,
                                    id: 'set_' + Date.now() + '_' + Math.floor(Math.random() * 1000), // Generate unique ID
                                    name: newName
                                };
                            });
                            
                            // Add imported sets to existing sets
                            customSets = [...customSets, ...importedSetsWithNewIds];
                            
                            // Add active sets from import (using the new IDs)
                            if (importData.activeSets && importData.activeSets.length > 0) {
                                // Map old IDs to new IDs
                                const oldToNewIdMap = {};
                                importData.customSets.forEach((oldSet, index) => {
                                    oldToNewIdMap[oldSet.id] = importedSetsWithNewIds[index].id;
                                });
                                
                                // Add mapped active sets to current active sets
                                const importedActiveSetIds = importData.activeSets
                                    .map(oldId => oldToNewIdMap[oldId])
                                    .filter(id => id); // Filter out any undefined mappings
                                
                                activeSets = [...new Set([...activeSets, ...importedActiveSetIds])];
                            }
                            
                            // Save to localStorage
                            saveCustomSets();
                            
                            // Update UI
                            renderCustomSetsList();
                            updateActiveSets();
                            
                            // Show success message
                            alert(`Successfully imported ${importedSetsWithNewIds.length} custom sets!`);
                            
                            // If we already have text in the textarea, update preview
                            const text = getEditableText();
                            if (text) {
                                updateCustomSetPreview(text);
                            }
                        } catch (error) {
                            console.error('Import error:', error);
                            alert('Error importing sets: ' + error.message);
                        }
                    };
                    
                    reader.readAsText(file);
                });
                
                // Trigger file selection
                fileInput.click();
            }
            
            // Update the preview with the selected set
            function updatePreview(setId) {
                const set = customSets.find(s => s.id === setId);
                if (!set) return;
                
                const previewContent = document.getElementById('previewContent');
                const description = document.getElementById('previewDescription');
                
                description.textContent = `Preview of "${set.name}" highlighting:`;
                
                // Get sample text from the main textarea or use a default
                let sampleText = getEditableText();
                if (!sampleText) {
                    sampleText = "The quick brown fox jumps over the lazy dog. She sells seashells by the seashore.";
                }
                
                // Generate preview with highlighted words
                let highlightedText = sampleText;
                
                if (set.useRegex) {
                    // Use regex patterns
                    set.words.forEach(pattern => {
                        try {
                            const regex = new RegExp(pattern, 'gi');
                            highlightedText = highlightedText.replace(regex, match => 
                                `<span style="background-color:${set.color};color:white;padding:0 3px;border-radius:3px;">${match}</span>`
                            );
                        } catch (error) {
                            console.error('Invalid regex pattern:', pattern, error);
                        }
                    });
                } else {
                    // Use word-based matching
                    set.words.forEach(word => {
                        // Create word boundary regex
                        const escapedWord = escapeRegExp(word);
                        const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
                        highlightedText = highlightedText.replace(regex, match => 
                            `<span style="background-color:${set.color};color:white;padding:0 3px;border-radius:3px;">${match}</span>`
                        );
                    });
                }
                
                previewContent.innerHTML = `<div dir="auto">${highlightedText}</div>`;
            }
            
            // Update the preview with all active sets
            function updateCustomSetPreview(text) {
                if (!text) return;
                
                const previewContent = document.getElementById('previewContent');
                const description = document.getElementById('previewDescription');
                
                if (activeSets.length === 0) {
                    description.textContent = 'Activate sets to preview highlighting';
                    previewContent.innerHTML = '<p class="italic text-gray-500 dark:text-gray-400 text-center">No active sets selected</p>';
                    return;
                }
                
                description.textContent = 'Preview with active sets:';
                
                // Apply highlighting from all active sets
                let highlightedText = applyCustomSetHighlighting(text, activeSets);
                
                previewContent.innerHTML = `<div dir="auto">${highlightedText}</div>`;
            }
            
            // Analyze text with custom sets - with style preservation
            function analyzeCustomSets(text) {
                // Save current formatting
                saveEditorContents();
                
                if (!text) {
                    alert('Please enter some text to analyze.');
                    return;
                }
                
                // Get the warning elements
                const noActiveSetsWarning = document.getElementById('noActiveSetsWarning');
                const noCustomMatchesWarning = document.getElementById('noCustomMatchesWarning');
                
                if (activeSets.length === 0) {
                    // No active sets, show warning and exit
                    noActiveSetsWarning.classList.remove('hidden');
                    noCustomMatchesWarning.classList.add('hidden');
                    return;
                } else {
                    // Hide the warning if sets are active
                    noActiveSetsWarning.classList.add('hidden');
                }
                
                // Count occurrences for statistics
                const setCounts = countCustomSetOccurrences(text, activeSets);
                
                // Check if any matches were found
                const totalMatches = Object.values(setCounts).reduce((sum, val) => sum + val.count, 0);
                
                // Keep a copy of the original formatting
                const originalContents = quill.getContents();
                
                if (totalMatches === 0) {
                    // No matches found
                    noCustomMatchesWarning.classList.remove('hidden');
                } else {
                    // Matches found, hide warning
                    noCustomMatchesWarning.classList.add('hidden');
                    
                    // Apply highlights to the Quill editor while preserving existing formatting
                    applyCustomSetHighlightingToQuill(text, activeSets);
                }
                
                // Update the stats container
                const statsContainer = document.getElementById('customSetsStatsContainer');
                const statsList = document.getElementById('customSetsStatsList');
                
                if (totalMatches > 0) {
                    // Clear previous stats
                    statsList.innerHTML = '';
                    
                    // Add data for each set with count > 0
                    Object.entries(setCounts)
                        .filter(([_, data]) => data.count > 0)
                        .sort((a, b) => b[1].count - a[1].count) // Sort by count (descending)
                        .forEach(([setId, data]) => {
                            const percentage = ((data.count / totalMatches) * 100).toFixed(1);
                            const listItem = document.createElement('li');
                            listItem.innerHTML = `
                                <div class="flex items-center">
                                    <span style="background-color:${data.color}" class="inline-block w-4 h-4 mr-2 rounded"></span>
                                    <span>${data.name}</span>
                                </div>
                                <span class="item-count">${data.count} (${percentage}%)</span>
                            `;
                            statsList.appendChild(listItem);
                        });
                    
                    // Update total count
                    document.getElementById('totalCustomSetMatches').textContent = totalMatches;
                    
                    // Show the stats container
                    statsContainer.classList.remove('hidden');
                } else {
                    // Hide the stats container if no matches found
                    statsContainer.classList.add('hidden');
                }
            }
            
            // Apply highlighting from custom sets to text
            function applyCustomSetHighlighting(text, activeSetIds) {
                if (!text || activeSetIds.length === 0) return text;
                
                // Create a mapping of character positions to highlight info
                // This prevents overlap issues when multiple sets match the same text
                const highlights = [];
                
                // Process each active set
                activeSetIds.forEach(setId => {
                    const set = customSets.find(s => s.id === setId);
                    if (!set) return;
                    
                    // Apply each word/pattern in the set
                    set.words.forEach(word => {
                        let matches = [];
                        
                        if (set.useRegex) {
                            // Use regex pattern matching
                            try {
                                const regex = new RegExp(word, 'gi');
                                let match;
                                while ((match = regex.exec(text)) !== null) {
                                    matches.push({
                                        start: match.index,
                                        end: match.index + match[0].length,
                                        text: match[0],
                                        setId: set.id,
                                        color: set.color,
                                        setName: set.name
                                    });
                                }
                            } catch (error) {
                                console.error('Invalid regex pattern:', word, error);
                            }
                        } else {
                            // Use word boundary matching that works with non-Latin scripts
                            const escapedWord = escapeRegExp(word);
                            
                            // Special handling for non-Latin scripts (e.g., Cyrillic, Arabic, Asian languages)
                            // This uses a lookahead/lookbehind approach to detect word boundaries
                            // without relying on \b which doesn't work well with non-Latin characters
                            const regex = new RegExp(`(^|[^\\p{L}\\p{N}])(${escapedWord})([^\\p{L}\\p{N}]|$)`, 'giu');
                            
                            let match;
                            while ((match = regex.exec(text)) !== null) {
                                // The actual word is in the second capture group
                                const actualWord = match[2];
                                const fullMatch = match[0];
                                const start = match.index + fullMatch.indexOf(actualWord);
                                
                                matches.push({
                                    start: start,
                                    end: start + actualWord.length,
                                    text: actualWord,
                                    setId: set.id,
                                    color: set.color,
                                    setName: set.name
                                });
                                
                                // Ensure we don't get stuck in an infinite loop by advancing the regex
                                // If the match has zero length, move forward by 1
                                if (match.index === regex.lastIndex) {
                                    regex.lastIndex++;
                                }
                            }
                        }
                        
                        // Add matches to highlights array
                        highlights.push(...matches);
                    });
                });
                
                // Sort highlights by position (descending order to avoid position shifts)
                highlights.sort((a, b) => b.start - a.start);
                
                // Apply highlights from end to beginning to maintain positions
                let result = text;
                highlights.forEach(highlight => {
                    const highlightedText = `<span style="background-color:${highlight.color};color:white;padding:0 3px;border-radius:3px;" data-set="${highlight.setId}">${highlight.text}</span>`;
                    result = result.substring(0, highlight.start) + highlightedText + result.substring(highlight.end);
                });
                
                return result;
            }
            
            // Apply custom set highlighting to Quill editor with style preservation
            function applyCustomSetHighlightingToQuill(text, activeSetIds) {
                if (!text || activeSetIds.length === 0) return;
                
                // Process each active set
                activeSetIds.forEach(setId => {
                    const set = customSets.find(s => s.id === setId);
                    if (!set) return;
                    
                    // Apply each word/pattern in the set
                    set.words.forEach(word => {
                        try {
                            if (set.useRegex) {
                                // Use regex pattern matching
                                const regex = new RegExp(word, 'gi');
                                let match;
                                let textContent = quill.getText();
                                
                                // Reset regex
                                regex.lastIndex = 0;
                                
                                // Find all matches
                                while ((match = regex.exec(textContent)) !== null) {
                                    // Apply formatting to this match
                                    quill.formatText(
                                        match.index,
                                        match[0].length,
                                        { 'background': set.color, 'color': 'white' },
                                        'api'  // Use 'api' source to avoid replacing other formats
                                    );
                                }
                            } else {
                                // Use word boundary matching
                                const escapedWord = escapeRegExp(word);
                                const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
                                let match;
                                let textContent = quill.getText();
                                
                                // Reset regex
                                regex.lastIndex = 0;
                                
                                // Find all matches
                                while ((match = regex.exec(textContent)) !== null) {
                                    // Apply formatting to this match
                                    quill.formatText(
                                        match.index,
                                        match[0].length,
                                        { 'background': set.color, 'color': 'white' },
                                        'api'  // Use 'api' source to avoid replacing other formats
                                    );
                                }
                            }
                        } catch (error) {
                            console.error('Error applying custom set highlighting:', error);
                        }
                    });
                });
            }
            
            // Count occurrences of custom set words in text
            function countCustomSetOccurrences(text, activeSetIds) {
                const counts = {};
                
                activeSetIds.forEach(setId => {
                    const set = customSets.find(s => s.id === setId);
                    if (!set) return;
                    
                    let totalCount = 0;
                    
                    // Count occurrences for each word/pattern
                    set.words.forEach(word => {
                        let count = 0;
                        
                        if (set.useRegex) {
                            // Use regex pattern matching
                            try {
                                const regex = new RegExp(word, 'gi');
                                const matches = text.match(regex);
                                if (matches) {
                                    count = matches.length;
                                }
                            } catch (error) {
                                console.error('Invalid regex pattern:', word, error);
                            }
                        } else {
                            // Use word boundary matching
                            const escapedWord = escapeRegExp(word);
                            const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
                            const matches = text.match(regex);
                            if (matches) {
                                count = matches.length;
                            }
                        }
                        
                        totalCount += count;
                    });
                    
                    counts[setId] = {
                        name: set.name,
                        color: set.color,
                        count: totalCount
                    };
                });
                
                return counts;
            }
            
            // Initialize Custom Sets functionality
            initCustomSets();
        });
    </script>
</body>
</html>